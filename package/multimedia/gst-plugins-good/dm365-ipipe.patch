diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2bufferpool.c gst-plugins-good-0.10.31/sys/v4l2/gstv4l2bufferpool.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2bufferpool.c	2011-12-30 14:59:13.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/gstv4l2bufferpool.c	2013-09-27 15:49:01.000000000 +0200
@@ -181,7 +181,6 @@ gst_v4l2_buffer_new (GstV4l2BufferPool *
     GST_LOG_OBJECT (pool->v4l2elem, "  MMAP offset:  %u",
         ret->vbuffer.m.offset);
   GST_LOG_OBJECT (pool->v4l2elem, "  length:    %u", ret->vbuffer.length);
-  GST_LOG_OBJECT (pool->v4l2elem, "  input:     %u", ret->vbuffer.input);
 
   data = (guint8 *) v4l2_mmap (0, ret->vbuffer.length,
       PROT_READ | PROT_WRITE, MAP_SHARED, pool->video_fd,
@@ -577,7 +576,11 @@ gst_v4l2_buffer_pool_dqbuf (GstV4l2Buffe
       GST_BUFFER_FLAG_UNSET (pool_buffer, GST_VIDEO_BUFFER_TFF);
 
     /* this can change at every frame, esp. with jpeg */
+#if defined(MVL_LSP) && ( defined(Platform_dm6467) || defined(Platform_dm357))
+    GST_BUFFER_SIZE (pool_buffer) = pool->bytesused;
+#else    
     GST_BUFFER_SIZE (pool_buffer) = buffer.bytesused;
+#endif
 
     GST_V4L2_BUFFER_POOL_UNLOCK (pool);
 
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2bufferpool.h gst-plugins-good-0.10.31/sys/v4l2/gstv4l2bufferpool.h
--- gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2bufferpool.h	2011-12-11 19:48:12.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/gstv4l2bufferpool.h	2013-09-27 15:49:01.000000000 +0200
@@ -64,6 +64,9 @@ struct _GstV4l2BufferPool
   gint video_fd;             /* a dup(2) of the v4l2object's video_fd */
   guint buffer_count;
   GstV4l2Buffer **buffers;
+  #if defined(MVL_LSP)
+  guint32 bytesused;
+  #endif
 };
 
 struct _GstV4l2Buffer {
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2object.c gst-plugins-good-0.10.31/sys/v4l2/gstv4l2object.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2object.c	2011-12-30 14:59:13.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/gstv4l2object.c	2013-09-27 22:27:35.000000000 +0200
@@ -49,9 +49,14 @@
 #define V4L2_FIELD_INTERLACED_BT 9
 #endif
 
+#include "v4l2_dm365_ipipe.h"
+
 GST_DEBUG_CATEGORY_EXTERN (v4l2_debug);
 #define GST_CAT_DEFAULT v4l2_debug
 
+#if defined(MVL_LSP)
+#include "v4l2src_mvl_lsp.h"
+#endif
 
 #define DEFAULT_PROP_DEVICE_NAME 	NULL
 #define DEFAULT_PROP_DEVICE_FD          -1
@@ -487,6 +492,19 @@ gst_v4l2_object_new (GstElement * elemen
 
   v4l2object->xwindow_id = 0;
 
+  #if defined(USE_DM365_IPIPE)
+  v4l2object->davinci_resizer_dev = NULL;
+  v4l2object->davinci_resizer_fd  = -1;
+
+  v4l2object->davinci_previewer_dev = NULL;
+  v4l2object->davinci_previewer_fd  = -1;
+  v4l2object->chain_ipipe = TRUE;
+  #endif
+
+  v4l2object->pushed_frame_count_1000x = 0UL;
+  v4l2object->push_rate_1000x          = 0UL;
+  v4l2object->next_pushed_frame_1000x  = 0UL;
+
   return v4l2object;
 }
 
@@ -511,6 +529,20 @@ gst_v4l2_object_destroy (GstV4l2Object *
     gst_v4l2_object_clear_format_list (v4l2object);
   }
 
+  if (v4l2object->input_src) {
+    g_free (v4l2object->input_src);
+  }
+
+  #if defined(USE_DM365_IPIPE)
+  if (v4l2object->davinci_resizer_dev) {
+    g_free (v4l2object->davinci_resizer_dev);
+  }
+
+  if (v4l2object->davinci_previewer_dev) {
+    g_free (v4l2object->davinci_previewer_dev);
+  }
+  #endif
+
   g_free (v4l2object);
 }
 
@@ -851,6 +883,12 @@ static const GstV4L2FormatDesc gst_v4l2_
 #ifdef V4L2_PIX_FMT_YVYU
   {V4L2_PIX_FMT_YVYU, TRUE},
 #endif
+#ifdef V4L2_PIX_FMT_NV16
+  {V4L2_PIX_FMT_NV16, TRUE},
+#endif
+#ifdef V4L2_PIX_FMT_YUV422UVP
+  {V4L2_PIX_FMT_YUV422UVP, TRUE},
+#endif
 };
 
 #define GST_V4L2_FORMAT_COUNT (G_N_ELEMENTS (gst_v4l2_formats))
@@ -1255,6 +1293,12 @@ gst_v4l2_object_v4l2fourcc_to_structure
 #ifdef V4L2_PIX_FMT_YVYU
     case V4L2_PIX_FMT_YVYU:
 #endif
+#ifdef V4L2_PIX_FMT_NV16
+    case V4L2_PIX_FMT_NV16:
+#endif
+#ifdef V4L2_PIX_FMT_YUV422UVP
+    case V4L2_PIX_FMT_YUV422UVP:
+#endif
     case V4L2_PIX_FMT_YUV411P:{
       guint32 fcc = 0;
 
@@ -1297,6 +1341,16 @@ gst_v4l2_object_v4l2fourcc_to_structure
           fcc = GST_MAKE_FOURCC ('Y', 'V', 'Y', 'U');
           break;
 #endif
+#ifdef V4L2_PIX_FMT_NV16
+       case V4L2_PIX_FMT_NV16:
+         fcc = GST_MAKE_FOURCC ('N', 'V', '1', '6');
+         break;
+#endif
+#ifdef V4L2_PIX_FMT_YUV422UVP
+       case V4L2_PIX_FMT_YUV422UVP:
+         fcc = GST_MAKE_FOURCC ('Y', '8', 'C', '8');
+         break;
+#endif
         default:
           g_assert_not_reached ();
           break;
@@ -1464,8 +1518,9 @@ gst_v4l2_object_get_caps_info (GstV4l2Ob
         break;
       case GST_MAKE_FOURCC ('N', 'V', '1', '2'):
         fourcc = V4L2_PIX_FMT_NV12;
-        outsize = GST_ROUND_UP_4 (*w) * GST_ROUND_UP_2 (*h);
-        outsize += (GST_ROUND_UP_4 (*w) * *h) / 2;
+        /* NV12 buffer on dm365 is 32-byte aligned */
+        outsize = GST_ROUND_UP_32 (*w) * GST_ROUND_UP_2 (*h);
+        outsize += (GST_ROUND_UP_32 (*w) * *h) / 2;
         break;
       case GST_MAKE_FOURCC ('N', 'V', '2', '1'):
         fourcc = V4L2_PIX_FMT_NV21;
@@ -1540,10 +1595,11 @@ done:
 }
 
 
+#if !defined(MVL_LSP)
 static gboolean
 gst_v4l2_object_get_nearest_size (GstV4l2Object * v4l2object,
     guint32 pixelformat, gint * width, gint * height, gboolean * interlaced);
-
+#endif
 
 /* The frame interval enumeration code first appeared in Linux 2.6.19. */
 #ifdef VIDIOC_ENUM_FRAMEINTERVALS
@@ -1930,6 +1986,12 @@ default_frame_sizes:
     gboolean interlaced;
 
     /* This code is for Linux < 2.6.19 */
+#if defined(MVL_LSP)
+    gst_v4l2src_get_resolution(v4l2object, &min_w, &min_h, &fix_num, 
+        &fix_denom); 
+    gst_v4l2src_get_resolution(v4l2object, &max_w, &max_h, &fix_num, 
+        &fix_denom);
+#else
     min_w = min_h = 1;
     max_w = max_h = GST_V4L2_MAX_SIZE;
     if (!gst_v4l2_object_get_nearest_size (v4l2object, pixelformat, &min_w,
@@ -1944,7 +2006,8 @@ default_frame_sizes:
           "Could not probe maximum capture size for pixelformat %"
           GST_FOURCC_FORMAT, GST_FOURCC_ARGS (pixelformat));
     }
-
+#endif
+   
     /* Since we can't get framerate directly, try to use the current norm */
     if (v4l2object->tv_norm && v4l2object->norms) {
       GList *norms;
@@ -1959,8 +2022,10 @@ default_frame_sizes:
       }
       /* If it's possible, set framerate to that (discrete) value */
       if (norm) {
+#if !defined(MVL_LSP)
         fix_num = gst_value_get_fraction_numerator (&norm->framerate);
         fix_denom = gst_value_get_fraction_denominator (&norm->framerate);
+#endif
       }
     }
 
@@ -1994,6 +2059,7 @@ default_frame_sizes:
   }
 }
 
+#if !defined(MVL_LSP)
 static gboolean
 gst_v4l2_object_get_nearest_size (GstV4l2Object * v4l2object,
     guint32 pixelformat, gint * width, gint * height, gboolean * interlaced)
@@ -2025,8 +2091,19 @@ gst_v4l2_object_get_nearest_size (GstV4l
   fmt.fmt.pix.pixelformat = pixelformat;
   fmt.fmt.pix.field = V4L2_FIELD_NONE;
 
+#if defined(V4L2_PIX_FMT_NV16)
+  /* Set the bytesperline and sizeimage fields when using the NV16 colorspace.
+   * Some drivers, such as the DM6467T component capture driver expects these
+   * fields to be set.
+   */
+  if (pixelformat == V4L2_PIX_FMT_NV16) {
+    fmt.fmt.pix.bytesperline = (*width); 
+    fmt.fmt.pix.sizeimage    = (fmt.fmt.pix.bytesperline * (*height)) << 1;
+  }
+#endif
+
   r = v4l2_ioctl (fd, VIDIOC_TRY_FMT, &fmt);
-  if (r < 0 && errno == EINVAL) {
+  if (r < 0 && (errno == EINVAL || errno == EPERM)) {
     /* try again with interlaced video */
     fmt.fmt.pix.width = *width;
     fmt.fmt.pix.height = *height;
@@ -2053,7 +2130,7 @@ gst_v4l2_object_get_nearest_size (GstV4l
     fmt.fmt.pix.height = *height;
 
     r = v4l2_ioctl (fd, VIDIOC_S_FMT, &fmt);
-    if (r < 0 && errno == EINVAL) {
+    if (r < 0 && (errno == EINVAL || errno == EPERM)) {
       /* try again with progressive video */
       fmt.fmt.pix.width = *width;
       fmt.fmt.pix.height = *height;
@@ -2098,6 +2175,7 @@ error:
     v4l2_ioctl (fd, VIDIOC_S_FMT, &prevfmt);
   return FALSE;
 }
+#endif
 
 
 gboolean
@@ -2136,29 +2214,28 @@ gst_v4l2_object_set_format (GstV4l2Objec
   if (v4l2_ioctl (fd, VIDIOC_G_FMT, &format) < 0)
     goto get_fmt_failed;
 
-  if (format.type == v4l2object->type &&
-      format.fmt.pix.width == width &&
-      format.fmt.pix.height == height &&
-      format.fmt.pix.pixelformat == pixelformat &&
-      format.fmt.pix.field == field) {
-    /* Nothing to do. We want to succeed immediately
-     * here because setting the same format back
-     * can still fail due to EBUSY. By short-circuiting
-     * here, we allow pausing and re-playing pipelines
-     * with changed caps, as long as the changed caps
-     * do not change the webcam's format. Otherwise,
-     * any caps change would require us to go to NULL
-     * state to close the device and set format.
-     */
-    return TRUE;
-  }
-
   format.type = v4l2object->type;
   format.fmt.pix.width = width;
   format.fmt.pix.height = height;
   format.fmt.pix.pixelformat = pixelformat;
   format.fmt.pix.field = field;
 
+  #if defined(MVL_LSP) 
+    v4l2object->bytesused = format.fmt.pix.sizeimage;
+  #endif
+
+  /* Set the bytesperline and sizeimage fields when using the NV16 colorspace.
+   * Some drivers, such as the DM6467T component capture driver expects these
+   * fields to be set.
+   */
+  #if defined(V4L2_PIX_FMT_NV16)
+    if (pixelformat == V4L2_PIX_FMT_NV16) {
+      format.fmt.pix.bytesperline = width; 
+      format.fmt.pix.sizeimage    =
+        (format.fmt.pix.bytesperline * height) << 1;
+    }
+  #endif
+
   if (v4l2_ioctl (fd, VIDIOC_S_FMT, &format) < 0) {
     goto set_fmt_failed;
   }
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2object.h gst-plugins-good-0.10.31/sys/v4l2/gstv4l2object.h
--- gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2object.h	2011-12-30 14:59:13.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/gstv4l2object.h	2013-09-28 01:03:08.000000000 +0200
@@ -39,10 +39,10 @@
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #ifndef __sun
-#include <linux/types.h>
+//#include <linux/types.h>
 #define _LINUX_TIME_H
 #define __user
-#include <linux/videodev2.h>
+#include "videodev2.h"
 #else
 #include <sys/videodev2.h>
 #endif
@@ -53,6 +53,7 @@
 
 #include <gst/interfaces/propertyprobe.h>
 
+#define USE_DM365_IPIPE
 
 /* size of v4l2 buffer pool in streaming case */
 #define GST_V4L2_MAX_BUFFERS 16
@@ -86,6 +87,24 @@ struct _GstV4l2Object {
   GstPoll * poll;
   gboolean can_poll_device;
 
+  #if defined(USE_DM365_IPIPE)
+  /* the resizer device and file descriptor */
+  char *davinci_resizer_dev;
+  gint  davinci_resizer_fd;
+
+  /* the previewer device and file descriptor */
+  char *davinci_previewer_dev;
+  gint  davinci_previewer_fd;
+
+  /* choose if we want the ipipe to be chained or not */
+  gboolean chain_ipipe;
+  #endif
+
+  /* how many capture frames to drop for each frame pushed */
+  guint32 pushed_frame_count_1000x;
+  guint32 push_rate_1000x;
+  guint32 next_pushed_frame_1000x;
+
   /* the video buffer (mmap()'ed) */
   guint8 **buffer;
 
@@ -111,6 +130,8 @@ struct _GstV4l2Object {
   v4l2_std_id tv_norm;
   gchar *channel;
   gulong frequency;
+  gchar *input_src;
+  gint   input_id;
 
   /* X-overlay */
   GstV4l2Xv *xv;
@@ -120,6 +141,14 @@ struct _GstV4l2Object {
   GstV4l2GetInOutFunction  get_in_out_func;
   GstV4l2SetInOutFunction  set_in_out_func;
   GstV4l2UpdateFpsFunction update_fps_func;
+
+#if defined(MVL_LSP)
+  gboolean force_720p_30;
+#endif
+#if defined(MVL_LSP)
+  guint32 bytesused;
+#endif
+
 };
 
 struct _GstV4l2ObjectClassHelper {
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2src.c gst-plugins-good-0.10.31/sys/v4l2/gstv4l2src.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/gstv4l2src.c	2012-01-18 11:03:22.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/gstv4l2src.c	2013-09-27 22:30:27.000000000 +0200
@@ -66,6 +66,7 @@ GST_DEBUG_CATEGORY (v4l2src_debug);
 #define PROP_DEF_QUEUE_SIZE         2
 #define PROP_DEF_ALWAYS_COPY        TRUE
 #define PROP_DEF_DECIMATE           1
+#define PROP_DEF_CHAIN_IPIPE        TRUE
 
 #define DEFAULT_PROP_DEVICE   "/dev/video0"
 
@@ -75,7 +76,14 @@ enum
   V4L2_STD_OBJECT_PROPS,
   PROP_QUEUE_SIZE,
   PROP_ALWAYS_COPY,
-  PROP_DECIMATE
+  PROP_DECIMATE,
+#if defined(MVL_LSP)
+  PROP_FORCE_720P_30,
+#endif  
+#if defined(USE_DM365_IPIPE)
+  PROP_CHAIN_IPIPE,
+#endif
+  PROP_INPUT_SRC
 };
 
 GST_IMPLEMENT_V4L2_PROBE_METHODS (GstV4l2SrcClass, gst_v4l2src);
@@ -285,6 +293,23 @@ gst_v4l2src_class_init (GstV4l2SrcClass
           "Only use every nth frame", 1, G_MAXINT,
           PROP_DEF_DECIMATE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+#if defined(MVL_LSP)
+  g_object_class_install_property (gobject_class, PROP_FORCE_720P_30,
+      g_param_spec_boolean ("force-720p-30", "Configure 720P @ 30fps",
+          "Force driver to work on 720P @ 30fps",
+          FALSE, G_PARAM_READWRITE));
+#endif 
+
+  g_object_class_install_property (gobject_class, PROP_INPUT_SRC,
+      g_param_spec_string ("input-src", "Select the input source",
+          "Select the input source", NULL, G_PARAM_READWRITE)); 
+
+#if defined(USE_DM365_IPIPE)
+  g_object_class_install_property (gobject_class, PROP_CHAIN_IPIPE,
+      g_param_spec_boolean ("chain-ipipe", "Chain the IPIPE",
+          "Selects if the ipipe will be chained or not", PROP_DEF_CHAIN_IPIPE, G_PARAM_READWRITE));
+#endif
+
   basesrc_class->get_caps = GST_DEBUG_FUNCPTR (gst_v4l2src_get_caps);
   basesrc_class->set_caps = GST_DEBUG_FUNCPTR (gst_v4l2src_set_caps);
   basesrc_class->start = GST_DEBUG_FUNCPTR (gst_v4l2src_start);
@@ -313,6 +338,19 @@ gst_v4l2src_init (GstV4l2Src * v4l2src,
   v4l2src->decimate = PROP_DEF_DECIMATE;
 
   v4l2src->is_capturing = FALSE;
+  v4l2src->v4l2object->input_src = NULL;
+#if defined(MVL_LSP)
+  v4l2src->v4l2object->force_720p_30 = FALSE;
+#endif
+#if defined(USE_DM365_IPIPE)
+  v4l2src->v4l2object->chain_ipipe = PROP_DEF_CHAIN_IPIPE;
+#endif
+/* Set the default input ID on a per-target basis */
+#if defined(MVL_LSP)
+  v4l2src->v4l2object->input_id = 4;  /* Component (MVL) */
+#else
+  v4l2src->v4l2object->input_id = 2;  /* Component */
+#endif
 
   gst_base_src_set_format (GST_BASE_SRC (v4l2src), GST_FORMAT_TIME);
   gst_base_src_set_live (GST_BASE_SRC (v4l2src), TRUE);
@@ -362,6 +400,20 @@ gst_v4l2src_set_property (GObject * obje
       case PROP_DECIMATE:
         v4l2src->decimate = g_value_get_int (value);
         break;
+      case PROP_INPUT_SRC:
+        v4l2src->v4l2object->input_src =
+          g_ascii_strup(g_value_get_string(value), -1);
+        break;
+#if defined(MVL_LSP)
+      case PROP_FORCE_720P_30:
+        v4l2src->v4l2object->force_720p_30 = g_value_get_boolean (value);
+        break;
+#endif
+#if defined(USE_DM365_IPIPE)
+      case PROP_CHAIN_IPIPE:
+        v4l2src->v4l2object->chain_ipipe = g_value_get_boolean (value);
+        break;
+#endif
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -388,6 +440,19 @@ gst_v4l2src_get_property (GObject * obje
       case PROP_DECIMATE:
         g_value_set_int (value, v4l2src->decimate);
         break;
+      case PROP_INPUT_SRC:
+        g_value_set_string(value, v4l2src->v4l2object->input_src);
+        break;
+#if defined(MVL_LSP)
+      case PROP_FORCE_720P_30:
+        g_value_set_boolean (value, v4l2src->v4l2object->force_720p_30);
+        break;
+#endif
+#if defined(USE_DM365_IPIPE)
+      case PROP_CHAIN_IPIPE:
+        g_value_set_boolean (value, v4l2src->v4l2object->chain_ipipe);
+        break;
+#endif
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -909,6 +974,21 @@ again:
   if (G_UNLIKELY (ret != GST_FLOW_OK))
     goto done;
 
+  /* Skip frames if needed to artificially lower the frame rate */
+  if (v4l2src->v4l2object->push_rate_1000x > 0) {
+    if (v4l2src->v4l2object->pushed_frame_count_1000x <
+         v4l2src->v4l2object->next_pushed_frame_1000x) {
+      gst_buffer_unref (temp);
+      goto again;
+    } else {
+      v4l2src->v4l2object->next_pushed_frame_1000x =
+          v4l2src->v4l2object->next_pushed_frame_1000x  -
+          v4l2src->v4l2object->pushed_frame_count_1000x +
+          v4l2src->v4l2object->push_rate_1000x;
+      v4l2src->v4l2object->pushed_frame_count_1000x = 0;
+    }
+  }
+
   if (v4l2src->frame_byte_size > 0) {
     size = GST_BUFFER_SIZE (temp);
 
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/Makefile.am gst-plugins-good-0.10.31/sys/v4l2/Makefile.am
--- gst-plugins-good-0.10.31.orig/sys/v4l2/Makefile.am	2011-12-11 19:48:12.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/Makefile.am	2013-09-27 15:53:48.000000000 +0200
@@ -17,7 +17,9 @@ libgstvideo4linux2_la_SOURCES = gstv4l2.
 				gstv4l2tuner.c \
 				gstv4l2vidorient.c \
 				v4l2_calls.c \
+				v4l2_dm365_ipipe.c\
 				v4l2src_calls.c \
+				v4l2src_mvl_lsp.c \
 				$(xv_source)
 
 if BUILD_EXPERIMENTAL
@@ -57,4 +59,6 @@ noinst_HEADERS = \
 	gstv4l2vidorient.h \
 	gstv4l2xoverlay.h \
 	v4l2_calls.h \
-	v4l2src_calls.h
+	v4l2_dm365_ipipe.h \
+	v4l2src_calls.h \
+	v4l2src_mvl_lsp.h
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/Makefile.in gst-plugins-good-0.10.31/sys/v4l2/Makefile.in
--- gst-plugins-good-0.10.31.orig/sys/v4l2/Makefile.in	2012-02-21 01:09:05.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/Makefile.in	2013-09-27 22:12:46.000000000 +0200
@@ -135,6 +135,7 @@ am_libgstvideo4linux2_la_OBJECTS = libgs
 	libgstvideo4linux2_la-gstv4l2radio.lo \
 	libgstvideo4linux2_la-gstv4l2tuner.lo \
 	libgstvideo4linux2_la-gstv4l2vidorient.lo \
+	libgstvideo4linux2_la-v4l2_dm365_ipipe.lo \
 	libgstvideo4linux2_la-v4l2_calls.lo \
 	libgstvideo4linux2_la-v4l2src_calls.lo $(am__objects_1) \
 	$(am__objects_2)
@@ -146,7 +147,7 @@ libgstvideo4linux2_la_LINK = $(LIBTOOL)
 	$(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) \
 	$(libgstvideo4linux2_la_LDFLAGS) $(LDFLAGS) -o $@
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir) -I$(DEVDIR)/kernel/include
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
@@ -508,7 +509,7 @@ plugin_LTLIBRARIES = libgstvideo4linux2.
 libgstvideo4linux2_la_SOURCES = gstv4l2.c gstv4l2colorbalance.c \
 	gstv4l2object.c gstv4l2bufferpool.c gstv4l2src.c \
 	gstv4l2radio.c gstv4l2tuner.c gstv4l2vidorient.c v4l2_calls.c \
-	v4l2src_calls.c $(xv_source) $(am__append_1)
+	v4l2src_calls.c v4l2_dm365_ipipe.c $(xv_source) $(am__append_1)
 libgstvideo4linux2_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) \
 				 $(GST_BASE_CFLAGS) \
 				 $(GST_CONTROLLER_CFLAGS) \
@@ -541,6 +542,8 @@ noinst_HEADERS = \
 	gstv4l2vidorient.h \
 	gstv4l2xoverlay.h \
 	v4l2_calls.h \
+	v4l2_dm365_ipipe.h \
+	v4l2src_mvl_lsp.h \
 	v4l2src_calls.h
 
 all: all-am
@@ -627,6 +630,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstvideo4linux2_la-gstv4l2tuner.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstvideo4linux2_la-gstv4l2vidorient.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstvideo4linux2_la-gstv4l2xoverlay.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstvideo4linux2_la-v4l2_dm365_ipipe.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstvideo4linux2_la-v4l2_calls.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Plo@am__quote@
 
@@ -714,6 +718,20 @@ libgstvideo4linux2_la-v4l2_calls.lo: v4l
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2_calls.lo `test -f 'v4l2_calls.c' || echo '$(srcdir)/'`v4l2_calls.c
 
+libgstvideo4linux2_la-v4l2_dm365_ipipe.lo: v4l2_dm365_ipipe.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-v4l2_dm365_ipipe.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-v4l2_dm365_ipipe.Tpo -c -o libgstvideo4linux2_la-v4l2_dm365_ipipe.lo `test -f 'v4l2_dm365_ipipe.c' || echo '$(srcdir)/'`v4l2_dm365_ipipe.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libgstvideo4linux2_la-v4l2_dm365_ipipe.Tpo $(DEPDIR)/libgstvideo4linux2_la-v4l2_dm365_ipipe.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='v4l2_dm365_ipipe.c' object='libgstvideo4linux2_la-v4l2_dm365_ipipe.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2_dm365_ipipe.lo `test -f 'v4l2_dm365_ipipe.c' || echo '$(srcdir)/'`v4l2_dm365_ipipe.c
+
+libgstvideo4linux2_la-v4l2src_mvl_lsp.lo: v4l2src_mvl_lsp.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-v4l2src_mvl_lsp.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-v4l2src_mvl_lsp.Tpo -c -o libgstvideo4linux2_la-v4l2src_mvl_lsp.lo `test -f 'v4l2src_mvl_lsp.c' || echo '$(srcdir)/'`v4l2src_mvl_lsp.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libgstvideo4linux2_la-v4l2src_mvl_lsp.Tpo $(DEPDIR)/libgstvideo4linux2_la-v4l2src_mvl_lsp.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='v4l2src_mvl_lsp.c' object='libgstvideo4linux2_la-v4l2src_mvl_lsp.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2src_mvl_lsp.lo `test -f 'v4l2src_mvl_lsp.c' || echo '$(srcdir)/'`v4l2src_mvl_lsp.c
+
 libgstvideo4linux2_la-v4l2src_calls.lo: v4l2src_calls.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-v4l2src_calls.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Tpo -c -o libgstvideo4linux2_la-v4l2src_calls.lo `test -f 'v4l2src_calls.c' || echo '$(srcdir)/'`v4l2src_calls.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Tpo $(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Plo
@@ -721,6 +739,13 @@ libgstvideo4linux2_la-v4l2src_calls.lo:
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2src_calls.lo `test -f 'v4l2src_calls.c' || echo '$(srcdir)/'`v4l2src_calls.c
 
+libgstvideo4linux2_la-v4l2src_dm365_ipipe.lo: v4l2src_dm365_ipipe.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-v4l2src_dm365_ipipe.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-v4l2src_dm365_ipipe.Tpo -c -o libgstvideo4linux2_la-v4l2src_dm365_ipipe.lo `test -f 'v4l2src_dm365_ipipe.c' || echo '$(srcdir)/'`v4l2src_dm365_ipipe.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libgstvideo4linux2_la-v4l2src_dm365_ipipe.Tpo $(DEPDIR)/libgstvideo4linux2_la-v4l2src_dm365_ipipe.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='v4l2src_dm365_ipipe.c' object='libgstvideo4linux2_la-v4l2src_dm365_ipipe.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2src_dm365_ipipe.lo `test -f 'v4l2src_calls.c' || echo '$(srcdir)/'`v4l2src_dm365_ipipe.c
+
 libgstvideo4linux2_la-gstv4l2xoverlay.lo: gstv4l2xoverlay.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-gstv4l2xoverlay.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-gstv4l2xoverlay.Tpo -c -o libgstvideo4linux2_la-gstv4l2xoverlay.lo `test -f 'gstv4l2xoverlay.c' || echo '$(srcdir)/'`gstv4l2xoverlay.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libgstvideo4linux2_la-gstv4l2xoverlay.Tpo $(DEPDIR)/libgstvideo4linux2_la-gstv4l2xoverlay.Plo
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/README gst-plugins-good-0.10.31/sys/v4l2/README
--- gst-plugins-good-0.10.31.orig/sys/v4l2/README	2011-12-11 19:48:12.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-v4l2 plugins
-============
-
-The idea is a bit the same as the idea for the v4l1 plugins. We want
-one generic v4l2element, and a few child objects (probably only two:
-v4l2src and v4l2sink):
-
-                /-------- v4l2src
-v4l2element ---=
-                \-------- v4l2sink
-
-Both v4l2src and v4l2sink have a uncompressed and a compressed
-recording-/playback-mode. Since this is all part of v4l2, the 'client'
-of these elements, i.e. an application using v4l2src/v4l2sink, will
-hardly notice this. All capsnego stuff is done inside, and the plugin
-knows which formats are compressed and which are not.
-
-Please note that the v4l1 and the v4l2 plugins are *not* compatible
-concerning properties. Naming has been kept the same where possible,
-but in some cases, properties had to be removed or added to make
-full use of v4l2.
-
-V4L2 API: http://linux.bytesex.org/v4l2/.
-          http://v4l2spec.bytesex.org/
-          /usr/include/linux/videodev2.h or
-
-Kernel patches available from
-          http://dl.bytesex.org/patches/.
-
-Articles:
-          http://lwn.net/Articles/203924/
-
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_calls.c gst-plugins-good-0.10.31/sys/v4l2/v4l2_calls.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_calls.c	2012-02-17 11:48:47.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2_calls.c	2013-09-27 22:27:06.000000000 +0200
@@ -53,6 +53,13 @@
 
 #include "gst/gst-i18n-plugin.h"
 
+#if defined(MVL_LSP)
+#include "v4l2src_mvl_lsp.h"
+#endif
+
+#include "v4l2_dm365_ipipe.h"
+
+
 /* Those are ioctl calls */
 #ifndef V4L2_CID_HCENTER
 #define V4L2_CID_HCENTER V4L2_CID_HCENTER_DEPRECATED
@@ -114,6 +121,8 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
 {
   gint n;
 
+  gboolean input_src_found = FALSE;
+
   GstElement *e;
 
   e = v4l2object->element;
@@ -128,6 +137,9 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
     GstV4l2TunerChannel *v4l2channel;
     GstTunerChannel *channel;
 
+    if (input_src_found)
+      break;
+
     memset (&input, 0, sizeof (input));
 
     input.index = n;
@@ -144,6 +156,48 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
       }
     }
 
+    /* If the input-src property was used, record the corresponding input */
+    if (v4l2object->input_src) {
+      gchar    *input_name  = g_ascii_strup((gchar*)input.name, -1);
+      gboolean  input_match;
+
+      input_match = (strcmp(input_name, v4l2object->input_src) == 0);
+
+      g_free(input_name);
+
+      if (input_match) {
+         input_src_found      = TRUE;
+         v4l2object->input_id = input.index;
+      }
+      else
+         continue;
+    }
+    else {
+      if (input.index != v4l2object->input_id)
+         continue;
+    }
+
+    /* Try setting the input and see if we can retrieve it as a valid setting.
+     * This is also needed to ensure the driver gets initialized properly.
+     */
+    if (gst_v4l2_set_input(v4l2object, input.index)) {
+      gint g_index;
+
+      if (!gst_v4l2_get_input(v4l2object, &g_index)) {
+        return FALSE;
+      }
+
+      if (input.index != g_index) {
+        GST_ELEMENT_ERROR (e, RESOURCE, SETTINGS,
+          (_("Attempted to set video input to %d in device '%s', "
+            "but it still has an input setting of %d.  Please make sure the "
+            "video input is connected properly."),
+            input.index, v4l2object->videodev, g_index),
+            NULL);
+          return FALSE;
+      }
+    }
+
     GST_LOG_OBJECT (e, "   index:     %d", input.index);
     GST_LOG_OBJECT (e, "   name:      '%s'", input.name);
     GST_LOG_OBJECT (e, "   type:      %08x", input.type);
@@ -248,6 +302,18 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
     if (n == V4L2_CID_LASTP1) {
       GST_DEBUG_OBJECT (e, "checking private CIDs");
       n = V4L2_CID_PRIVATE_BASE;
+      /* Skip detection of private controls.  Control information reported by
+       * the capture driver on DM365 (and possibly others) reports a large
+       * number of controls outside the recognized ranges, causing a very long
+       * delay while this code fails to detect any of them.  At this point, we
+       * haven't determined if the driver isn't V4L2 compliant here, reporting
+       * garbage values, or if there is some other issue.
+       *
+       * Previous versions of gst-plugins-good didn't support handling private
+       * controls, and for now we're re-instating that behavior here until the
+       * issue can be root-caused.
+       */
+       break;
     }
     GST_DEBUG_OBJECT (e, "checking control %08x", n);
 
@@ -294,8 +360,12 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
         break;
       case V4L2_CID_HFLIP:
       case V4L2_CID_VFLIP:
+#ifndef V4L2_CID_PAN_RESET
       case V4L2_CID_HCENTER:
+#endif
+#ifndef V4L2_CID_TILT_RESET
       case V4L2_CID_VCENTER:
+#endif
 #ifdef V4L2_CID_PAN_RESET
       case V4L2_CID_PAN_RESET:
 #endif
@@ -384,6 +454,12 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
   }
   v4l2object->colors = g_list_reverse (v4l2object->colors);
 
+  if (v4l2object->input_src && !input_src_found) {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, NOT_FOUND,
+        (_("Specified input-src '%s' was not found."),
+            v4l2object->input_src), NULL);
+  }
+
   GST_DEBUG_OBJECT (e, "done");
   return TRUE;
 }
@@ -419,6 +495,15 @@ gst_v4l2_open (GstV4l2Object * v4l2objec
   int libv4l2_fd;
   GstPollFD pollfd = GST_POLL_FD_INIT;
 
+  #if defined (USE_DM365_IPIPE)
+  if(v4l2object->chain_ipipe) {
+    if (gst_v4l2_dm365_ipipe_open(v4l2object) < 0)
+      GST_ERROR("failed to open IPIPE\n");
+    if (gst_v4l2_dm365_ipipe_init(v4l2object) < 0)
+      GST_ERROR("failed to initialize IPIPE\n");
+  }
+  #endif
+
   GST_DEBUG_OBJECT (v4l2object->element, "Trying to open device %s",
       v4l2object->videodev);
 
@@ -456,6 +541,10 @@ gst_v4l2_open (GstV4l2Object * v4l2objec
 
   v4l2object->can_poll_device = TRUE;
 
+  #if defined(Platform_dm6467t)
+    v4l2object->can_poll_device = FALSE;
+  #endif
+
   /* get capabilities, error will be posted */
   if (!gst_v4l2_get_capabilities (v4l2object))
     goto error;
@@ -561,6 +650,13 @@ gst_v4l2_close (GstV4l2Object * v4l2obje
   gst_poll_remove_fd (v4l2object->poll, &pollfd);
   v4l2object->video_fd = -1;
 
+  #if defined (USE_DM365_IPIPE)
+  if(v4l2object->chain_ipipe) {
+    if (gst_v4l2_dm365_ipipe_close(v4l2object) < 0)
+      GST_ERROR("failed to close IPIPE\n");
+  }
+  #endif
+
   /* empty lists */
   gst_v4l2_empty_lists (v4l2object);
 
@@ -581,8 +677,38 @@ gst_v4l2_get_norm (GstV4l2Object * v4l2o
   if (!GST_V4L2_IS_OPEN (v4l2object))
     return FALSE;
 
-  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_STD, norm) < 0)
-    goto std_failed;
+  /* It might take a few tries to detect the signal -- try up to 300 times */
+  {
+    int retries = 300;
+
+    while (retries-- > 0) {
+
+      /* Break-out of the retry loop on success, and abort if errno is not
+       * EAGAIN.
+       */
+      if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_QUERYSTD, norm) >= 0) {
+        break;
+      }
+      else if (errno != EAGAIN) {
+        goto std_failed;
+      }
+
+      /* Sleep for a microsecond before retrying */
+      usleep(1);
+    }
+
+    /* Abort if all 300 retry attempts failed */
+    if (retries == 0) {
+      goto std_failed;
+    }
+
+    /* On DM6467T, the convention is the set the norm after querying it,
+     * otherwise the driver won't initialize properly.
+     */
+    if (!gst_v4l2_set_norm(v4l2object, *norm)) {
+      goto std_failed;
+    }
+  }
 
   return TRUE;
 
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_calls.h gst-plugins-good-0.10.31/sys/v4l2/v4l2_calls.h
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_calls.h	2011-12-11 19:48:12.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2_calls.h	2013-09-28 01:03:08.000000000 +0200
@@ -30,7 +30,7 @@
 #  include <libv4l2.h>
 #else
 #  include <sys/ioctl.h>
-#  include <linux/videodev2.h>
+#  include "videodev2.h"
 #  define v4l2_fd_open(fd, flags) (fd)
 #  define v4l2_close    close
 #  define v4l2_dup      dup
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_dm365_ipipe.c gst-plugins-good-0.10.31/sys/v4l2/v4l2_dm365_ipipe.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_dm365_ipipe.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2_dm365_ipipe.c	2013-09-27 15:53:48.000000000 +0200
@@ -0,0 +1,548 @@
+/*
+ * v4l2_dm365_ipipe.c
+ *
+ * This file defines functions needed to configure the DM365 IPIPE in
+ * on-the-fly mode with the capture driver.  The capture driver by itself
+ * only supports UYVY, but using the IPIPE we can convert to NV12 on the
+ * fly during capture, which is the color format expected by some codecs.
+ *
+ * Original Author:
+ *     Don Darling, Texas Instruments, Inc.
+ *
+ * DMAI's capture code was heavily referenced for this implementation.
+ * DMAI uses the following license:
+ *
+ * --COPYRIGHT--,BSD
+ * Copyright (c) 2010, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--
+ */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+#include <string.h>
+
+#include <gst/gst.h>
+#include <gst/gst-i18n-plugin.h>
+#include "v4l2_dm365_ipipe.h"
+
+#ifdef USE_DM365_IPIPE
+
+#if defined(MVL_LSP)
+#include <asm/arch/imp_resizer.h>
+#include <asm/arch/imp_previewer.h>
+#include <asm/arch/dm365_ipipe.h>
+#else
+#include <media/davinci/imp_previewer.h>
+#include <media/davinci/imp_resizer.h>
+#include <media/davinci/dm365_ipipe.h>
+#endif
+
+/* Constants */
+static const char * davinci_resizer_dev   = "/dev/davinci_resizer";
+static const char * davinci_previewer_dev = "/dev/davinci_previewer";
+
+/* Static Functions */
+static gboolean
+gst_v4l2_dm365_resizer_open(GstV4l2Object * v4l2object);
+
+static gboolean
+gst_v4l2_dm365_resizer_init(GstV4l2Object * v4l2object);
+
+static gboolean
+gst_v4l2_dm365_resizer_close(GstV4l2Object * v4l2object);
+
+static gboolean
+gst_v4l2_dm365_previewer_open(GstV4l2Object * v4l2object);
+
+static gboolean
+gst_v4l2_dm365_previewer_init(GstV4l2Object * v4l2object);
+
+static gboolean
+gst_v4l2_dm365_previewer_close(GstV4l2Object * v4l2object);
+
+static gboolean
+gst_v4l2_dev_char_open(GstV4l2Object * v4l2object, const char *filename,
+  int *fd);
+
+static gboolean
+gst_v4l2_dev_char_close(GstV4l2Object * v4l2object, const char *filename,
+  int *fd);
+
+
+/*****************************************************************************
+ * gst_v4l2_dm365_ipipe_open():
+ *   Open the IPIPE devices
+ * return value: TRUE on success, FALSE on error
+ *****************************************************************************/
+gboolean
+gst_v4l2_dm365_ipipe_open (GstV4l2Object * v4l2object)
+{
+  if (!gst_v4l2_dm365_resizer_open(v4l2object))
+    return FALSE;
+  if (!gst_v4l2_dm365_previewer_open(v4l2object))
+    return FALSE;
+
+  return TRUE;
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_ipipe_init():
+ *   Initialize the IPIPE devices
+ * return value: TRUE on success, FALSE on error
+ *****************************************************************************/
+gboolean
+gst_v4l2_dm365_ipipe_init (GstV4l2Object * v4l2object)
+{
+  if (!gst_v4l2_dm365_resizer_init(v4l2object))
+    return FALSE;
+  if (!gst_v4l2_dm365_previewer_init(v4l2object))
+    return FALSE;
+
+  return TRUE;
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_ipipe_close():
+ *   Close the IPIPE devices
+ * return value: TRUE on success, FALSE on error
+ *****************************************************************************/
+gboolean
+gst_v4l2_dm365_ipipe_close (GstV4l2Object * v4l2object)
+{
+  if (!gst_v4l2_dm365_resizer_close(v4l2object))
+    return FALSE;
+  if (!gst_v4l2_dm365_previewer_close(v4l2object))
+    return FALSE;
+
+  return TRUE;
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_resizer_open():
+ *   Open the resizer device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dm365_resizer_open (GstV4l2Object * v4l2object)
+{
+  /* make sure we have a device to open */
+  if (!v4l2object->davinci_resizer_dev)
+    v4l2object->davinci_resizer_dev = g_strdup (davinci_resizer_dev);
+
+  return gst_v4l2_dev_char_open(v4l2object, v4l2object->davinci_resizer_dev,
+    &v4l2object->davinci_resizer_fd);
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_resizer_init():
+ *   Initialize the resizer device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dm365_resizer_init (GstV4l2Object * v4l2object)
+{
+  gint         *rsz_fd    = &v4l2object->davinci_resizer_fd;
+  unsigned int  user_mode = IMP_MODE_CONTINUOUS;
+  unsigned int  oper_mode;
+
+  struct rsz_channel_config    rsz_chan_config;
+  struct rsz_continuous_config rsz_cont_config;
+
+  /* make sure the resizer has been opened */
+  if (!GST_V4L2_RESIZER_IS_OPEN(v4l2object))
+    goto not_open;
+
+  /* set the operation mode to confinuous */
+  if (ioctl(*rsz_fd, RSZ_S_OPER_MODE, &user_mode) < 0)
+    goto cant_set_oper_mode;
+  if (ioctl(*rsz_fd, RSZ_G_OPER_MODE, &oper_mode) < 0)
+    goto cant_get_oper_mode;
+  if (oper_mode != user_mode)
+    goto set_mode_failed;
+
+  /* initialize resizer driver with default configuration */
+  memset(&rsz_chan_config, 0, sizeof(rsz_chan_config));
+  rsz_chan_config.oper_mode = oper_mode;
+  rsz_chan_config.chain     = 1;
+  rsz_chan_config.len       = 0;
+  rsz_chan_config.config    = NULL;
+
+  if (ioctl(*rsz_fd, RSZ_S_CONFIG, &rsz_chan_config) < 0)
+    goto init_resizer_failed;
+
+  /* retrieve all of the default configuration settings from the driver */
+  memset(&rsz_cont_config, 0, sizeof(rsz_cont_config));
+  rsz_chan_config.oper_mode = oper_mode;
+  rsz_chan_config.chain     = 1;
+  rsz_chan_config.len       = sizeof(rsz_cont_config);
+  rsz_chan_config.config    = &rsz_cont_config;
+
+  if (ioctl(*rsz_fd, RSZ_G_CONFIG, &rsz_chan_config) < 0)
+    goto get_config_failed;
+
+  /* modify the default settings for chaining and send the updated
+   * configuration back to the driver.
+   */
+  rsz_cont_config.output1.enable = 1;
+  rsz_cont_config.output2.enable = 0;
+  rsz_chan_config.len            = sizeof(rsz_cont_config);
+  rsz_chan_config.config         = &rsz_cont_config;
+  if (ioctl(*rsz_fd, RSZ_S_CONFIG, &rsz_chan_config) < 0)
+    goto set_config_failed;
+
+  return TRUE;
+
+  /* Errors */
+not_open:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Device '%s' is not open."), v4l2object->davinci_resizer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+cant_set_oper_mode:
+  {
+    /* Don't error out on this one -- this is just an indication that the
+     * hardware configuration cannot handle continuous mode.  The kernel
+     * command line option d365_imp.oper_mode needs to be set to 0.
+     */
+    GST_ELEMENT_INFO (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Cannot set operation mode on '%s'."),
+          v4l2object->davinci_resizer_dev),
+        NULL);
+    goto error;
+  }
+cant_get_oper_mode:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Cannot get operation mode on '%s'."),
+          v4l2object->davinci_resizer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+set_mode_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Failed to set continuous mode on '%s'."),
+          v4l2object->davinci_resizer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+init_resizer_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Failed to set default configuration on '%s'."),
+          v4l2object->davinci_resizer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+get_config_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Failed to get configuration settings on '%s'."),
+          v4l2object->davinci_resizer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+set_config_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Failed to set configuration on '%s'."),
+          v4l2object->davinci_resizer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+error:
+  {
+    close (*rsz_fd);
+    *rsz_fd = -1;
+    return FALSE;
+  }
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_resizer_close():
+ *   Close the resizer device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dm365_resizer_close (GstV4l2Object * v4l2object)
+{
+  return gst_v4l2_dev_char_close(v4l2object, v4l2object->davinci_resizer_dev,
+    &v4l2object->davinci_resizer_fd);
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_previewer_open():
+ *   Open the previewer device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dm365_previewer_open (GstV4l2Object * v4l2object)
+{
+  /* make sure we have a device to open */
+  if (!v4l2object->davinci_previewer_dev)
+    v4l2object->davinci_previewer_dev = g_strdup (davinci_previewer_dev);
+
+  return gst_v4l2_dev_char_open(v4l2object, v4l2object->davinci_previewer_dev,
+    &v4l2object->davinci_previewer_fd);
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_previewer_init():
+ *   Initialize the previewer device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dm365_previewer_init (GstV4l2Object * v4l2object)
+{
+  gint         *preview_fd = &v4l2object->davinci_previewer_fd;
+  unsigned int  user_mode  = IMP_MODE_CONTINUOUS;
+  unsigned int  oper_mode;
+
+  struct prev_channel_config prev_chan_config;
+
+  /* make sure the previewer has been opened */
+  if (!GST_V4L2_PREVIEWER_IS_OPEN(v4l2object))
+    goto not_open;
+
+  /* set the operation mode to confinuous */
+  if (ioctl(*preview_fd, PREV_S_OPER_MODE, &user_mode) < 0)
+    goto cant_set_oper_mode;
+  if (ioctl(*preview_fd, PREV_G_OPER_MODE, &oper_mode) < 0)
+    goto cant_get_oper_mode;
+  if (oper_mode != user_mode)
+    goto set_mode_failed;
+
+  /* initialize previewer driver with default configuration */
+  memset(&prev_chan_config, 0, sizeof(prev_chan_config));
+  prev_chan_config.oper_mode = oper_mode;
+  prev_chan_config.len       = 0;
+  prev_chan_config.config    = NULL;
+
+  if (ioctl(*preview_fd, PREV_S_CONFIG, &prev_chan_config) < 0)
+    goto init_previewer_failed;
+
+  /* default driver settings are adequate for the previewer -- no further
+   * modifications are needed.
+   */
+  return TRUE;
+
+  /* Errors */
+not_open:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Device '%s' is not open."), v4l2object->davinci_previewer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+cant_set_oper_mode:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Cannot set operation mode on '%s'."),
+          v4l2object->davinci_previewer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+cant_get_oper_mode:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Cannot get operation mode on '%s'."),
+          v4l2object->davinci_previewer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+set_mode_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Failed to set continuous mode on '%s'."),
+          v4l2object->davinci_previewer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+init_previewer_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,
+        (_("Failed to set default configuration on '%s'."),
+          v4l2object->davinci_previewer_dev),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+error:
+  {
+    close (*preview_fd);
+    *preview_fd = -1;
+    return FALSE;
+  }
+}
+
+/*****************************************************************************
+ * gst_v4l2_dm365_previewer_close():
+ *   Close the previewer device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dm365_previewer_close (GstV4l2Object * v4l2object)
+{
+  return gst_v4l2_dev_char_close(v4l2object, v4l2object->davinci_previewer_dev,
+    &v4l2object->davinci_previewer_fd);
+}
+
+/*****************************************************************************
+ * gst_v4l2_dev_char_open():
+ *   Open a character device for reading and writing
+ * return value:
+ *   TRUE on success, FALSE on error
+ *   Device file descriptor is returned in "fd"
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dev_char_open (GstV4l2Object * v4l2object, const char *filename,
+  int *fd)
+{
+  struct stat st;
+
+  /* make sure we have a device to open */
+  if (!filename)
+    goto no_file;
+
+  /* make sure it is a device file */
+  if (stat (filename, &st) == -1)
+    goto stat_failed;
+
+  if (!S_ISCHR (st.st_mode))
+    goto no_device;
+
+  /* open the device */
+  GST_DEBUG_OBJECT (v4l2object->element, "Trying to open device %s",
+    filename);
+
+  *fd = open(filename, O_RDWR);
+
+  if (*fd <= 0)
+    goto not_open;
+
+  GST_INFO_OBJECT (v4l2object->element, "Opened device '%s' successfully",
+    filename);
+
+  return TRUE;
+
+  /* Errors */
+no_file:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, NOT_FOUND,
+        (_("Device file not specified.")),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+stat_failed:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, READ,
+        (_("Cannot identify device '%s'."), filename),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+no_device:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, FAILED,
+        (_("This isn't a device '%s'."), filename),
+        GST_ERROR_SYSTEM);
+    goto error;
+  }
+not_open:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, OPEN_READ_WRITE,
+        (_("Could not open device '%s' for reading and writing."),
+            filename), GST_ERROR_SYSTEM);
+    goto error;
+  }
+error:
+  {
+    /* close the device if it was opened successfully */
+    if (*fd > 0) {
+      close (*fd);
+      *fd = -1;
+    }
+    return FALSE;
+  }
+}
+
+/*****************************************************************************
+ * gst_v4l2_dev_char_close():
+ *   Close a character device
+ * return value:
+ *   TRUE on success, FALSE on error
+ *****************************************************************************/
+static gboolean
+gst_v4l2_dev_char_close (GstV4l2Object * v4l2object, const char *filename,
+  int *fd)
+{
+  GST_DEBUG_OBJECT (v4l2object->element, "Trying to close %s",
+      filename);
+
+  if (*fd > 0) {
+    if (close (*fd) < 0)
+        goto fail_close;
+    *fd = -1;
+  }
+
+  GST_INFO_OBJECT (v4l2object->element, "Closed device '%s' successfully",
+    filename);
+
+  return TRUE;
+
+  /* Errors */
+fail_close:
+  {
+    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, CLOSE,
+        (_("Failed to close device '%s'."),
+            filename), GST_ERROR_SYSTEM);
+    goto error;
+  }
+error:
+  {
+    return FALSE;
+  }
+}
+
+#endif /* USE_DM365_IPIPE */
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_dm365_ipipe.h gst-plugins-good-0.10.31/sys/v4l2/v4l2_dm365_ipipe.h
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2_dm365_ipipe.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2_dm365_ipipe.h	2013-09-27 15:53:48.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * v4l2_dm365_ipipe.h
+ *
+ * This file defines functions needed to configure the DM365 IPIPE in
+ * on-the-fly mode with the capture driver.  The capture driver by itself
+ * only supports UYVY, but using the IPIPE we can convert to NV12 on the
+ * fly during capture, which is the color format expected by some codecs.
+ *
+ * DMAI's capture code was heavily referenced for this implementation, and in
+ * some places copied verbatim.  DMAI uses the following license:
+ *
+ * --COPYRIGHT--,BSD
+ * Copyright (c) 2010, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--
+ */
+#ifndef __V4L2_DM365_IPIPE_H__
+#define __V4L2_DM365_IPIPE_H__
+
+#include <glib/gtypes.h>
+#include "gstv4l2object.h"
+
+/* simple check whether the resizer is open */
+#define GST_V4L2_RESIZER_IS_OPEN(v4l2object) \
+  (v4l2object->davinci_resizer_fd > 0)
+
+/* simple check whether the previewer is open */
+#define GST_V4L2_PREVIEWER_IS_OPEN(v4l2object) \
+  (v4l2object->davinci_previewer_fd > 0)
+
+gboolean  gst_v4l2_dm365_ipipe_open   (GstV4l2Object * v4l2object);
+gboolean  gst_v4l2_dm365_ipipe_init   (GstV4l2Object * v4l2object);
+gboolean  gst_v4l2_dm365_ipipe_close  (GstV4l2Object * v4l2object);
+
+#endif /* __V4L2_DM365_IPIPE_H__ */
+
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2src_calls.c gst-plugins-good-0.10.31/sys/v4l2/v4l2src_calls.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2src_calls.c	2011-12-30 14:59:13.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2src_calls.c	2013-09-27 22:26:18.000000000 +0200
@@ -47,6 +47,10 @@
 
 #include "gst/gst-i18n-plugin.h"
 
+#if defined(MVL_LSP)
+#include "v4l2src_mvl_lsp.h"
+#endif
+
 #define GST_CAT_DEFAULT v4l2src_debug
 GST_DEBUG_CATEGORY_EXTERN (GST_CAT_PERFORMANCE);
 
@@ -86,6 +90,25 @@ queue_failed:
   }
 }
 
+/* Greatest common divisor */
+static guint32
+gst_v4l2src_gcd(guint32 a, guint32 b)
+{
+    guint32 r;
+
+    if (a < b) {
+        guint32 t = a;
+        a = b;
+        b = t;
+    }
+    while ((r = a % b) != 0) {
+        a = b;
+        b = r;
+    }
+    return b;
+}
+
+
 /******************************************************
  * gst_v4l2src_grab_frame ():
  *   grab a frame for capturing
@@ -107,6 +130,10 @@ gst_v4l2src_grab_frame (GstV4l2Src * v4l
   if (!pool)
     goto no_buffer_pool;
 
+  #if defined(MVL_LSP)
+  pool->bytesused = v4l2src->v4l2object->bytesused;
+  #endif
+
   GST_DEBUG_OBJECT (v4l2src, "grab frame");
 
   for (;;) {
@@ -127,8 +154,10 @@ gst_v4l2src_grab_frame (GstV4l2Src * v4l
     }
 
     pool_buffer = GST_BUFFER (gst_v4l2_buffer_pool_dqbuf (pool));
-    if (pool_buffer)
+    if (pool_buffer) {
+      v4l2src->v4l2object->pushed_frame_count_1000x += 1000;
       break;
+    }
 
     GST_WARNING_OBJECT (pool->v4l2elem, "trials=%d", trials);
 
@@ -245,7 +274,47 @@ gst_v4l2src_set_capture (GstV4l2Src * v4
   /* We want to change the frame rate, so check whether we can. Some cheap USB
    * cameras don't have the capability */
   if ((stream.parm.capture.capability & V4L2_CAP_TIMEPERFRAME) == 0) {
-    GST_DEBUG_OBJECT (v4l2src, "Not setting framerate (not supported)");
+     guint default_n = 0;
+     guint default_d = 0;
+
+     GST_DEBUG_OBJECT (v4l2src, "Not setting framerate (not supported)");
+
+     /* If we know the default framerate for this device, we can throw away
+      * frames to artifically lower the framerate to the one desired.  */
+     #if defined(Platform_dm6467) || defined(Platform_dm6467t)
+     {
+       const guint component_input_id = 1;
+       gint  current_input_id;
+       gst_v4l2_get_input(v4l2src->v4l2object, &current_input_id);
+
+       if (current_input_id == component_input_id) {
+              default_n = 60;
+              default_d = 1;
+       }
+      }
+      #endif
+
+      if (default_n > 0) {
+            guint32 div_n   = default_n * fps_d;
+            guint32 div_d   = default_d * fps_n;
+            guint32 div_gcd = gst_v4l2src_gcd(div_n, div_d);
+            guint32 push_rate_1000x;
+
+            div_n /= div_gcd;
+            div_d /= div_gcd;
+
+            push_rate_1000x = (div_n * 1000) / div_d;  
+
+      /* For every push_rate frames captured, push 1 downstream */
+      if (push_rate_1000x > 1000) {
+          GST_LOG_OBJECT (v4l2src, "A frame rate of %u/%u will be simulated "
+            "by only pushing 1 of every %2.4lf captured frames downstream",
+            fps_n, fps_d, push_rate_1000x / ((gdouble)1000));
+          v4l2src->v4l2object->push_rate_1000x         = push_rate_1000x;
+          v4l2src->v4l2object->next_pushed_frame_1000x = push_rate_1000x;
+      }
+    }
+
     goto done;
   }
 
@@ -358,6 +427,12 @@ gst_v4l2src_capture_start (GstV4l2Src *
   v4l2src->quit = FALSE;
 
   if (v4l2src->use_mmap) {
+#if defined(MVL_LSP)
+    if (v4l2src->v4l2object->force_720p_30) {
+        if (!gst_v4l2_force_720p_30(v4l2src))
+            return FALSE;
+    }
+#endif
     if (!gst_v4l2src_buffer_pool_activate (v4l2src->pool, v4l2src)) {
       return FALSE;
     }
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2src_mvl_lsp.c gst-plugins-good-0.10.31/sys/v4l2/v4l2src_mvl_lsp.c
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2src_mvl_lsp.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2src_mvl_lsp.c	2013-09-27 22:28:26.000000000 +0200
@@ -0,0 +1,232 @@
+/*
+ * v4l2src_mvl_lsp.c
+ *
+ * This file defines functions needed to get v4l2src on dm6446, dm355, dm6467
+ * , dm357 and dm365 LSP's.
+ *
+ *
+ * Most the code is copied from DMAI capture routines with following license:
+ *
+ * --COPYRIGHT--,BSD
+ * Copyright (c) 2009, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <ctype.h>
+#ifdef __sun
+/* Needed on older Solaris Nevada builds (72 at least) */
+#include <stropts.h>
+#include <sys/ioccom.h>
+#endif
+
+#include "v4l2src_mvl_lsp.h"
+
+#if defined(MVL_LSP)
+/******************************************************
+ * gst_v4l2src_get_resolution
+ *   get the video resolution
+ *****************************************************/
+void  gst_v4l2src_get_resolution (GstV4l2Object *v4l2object, gint *width, gint *height, gint *fps_num, gint *fps_denom)
+{
+  gint fd = v4l2object->video_fd;
+  v4l2_std_id  std;
+  gint failCount = 0, ret;
+  
+  do {
+    ret = ioctl(fd, VIDIOC_QUERYSTD, &std);
+    if (ret == -1 && errno == EAGAIN) {
+        usleep(1);
+        failCount++;
+    }
+  }while(ret == -1 && errno == EAGAIN && failCount < 5);
+
+  if (ret == -1) { 
+    GST_ERROR("failed to query standard, Video input connected ?\n");
+  }
+
+  /* It might take a few tries to detect the signal */
+  if (std & V4L2_STD_NTSC) {
+    GST_LOG("found ntsc standard\n");
+    *width = 720;
+    *height = 480;
+    *fps_num = 30000;
+    *fps_denom = 1001;
+  }
+  else if (std & V4L2_STD_PAL) {
+    GST_LOG("found pal standard\n");
+    *width = 720;
+    *height = 576;
+    *fps_num = 25;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_525P_60) {
+    GST_LOG("found 525p standard\n");
+    *width = 720;
+    *height = 480;
+    *fps_num = 30000;
+    *fps_denom = 1001;
+  }
+  else if (std & V4L2_STD_625P_50) {
+    GST_LOG("found 625p standard\n");
+    *width = 720;
+    *height = 576;
+    *fps_num = 25;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_720P_60) {
+    GST_LOG("found 720p @60fps standard\n");
+    *width = 1280;
+    *height = 720;
+    *fps_num = 60;
+    *fps_denom = 1;
+
+    if (v4l2object->force_720p_30) {
+        *fps_num = 30000;
+        *fps_denom = 1001;
+    }
+
+  }
+  else if (std & V4L2_STD_720P_50) {
+    GST_LOG("found 720p @50fps standard\n");
+    *width = 1280;
+    *height = 720;
+    *fps_num = 50;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080I_60) {
+    GST_LOG("found 1080i @60fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 60;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080I_50) {
+    GST_LOG("found 1080i @50fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 50;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080P_30) {
+    GST_LOG("found 1080p @30fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 30;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080P_25) {
+    GST_LOG("found 1080p @25fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 25;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080P_24) {
+    GST_LOG("found 1080p @24fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 24;
+    *fps_denom = 1;
+  }
+  else {
+    GST_WARNING("failed to detect video standard\n");
+    *width = 1;
+    *height = 1;
+    *fps_num = 1;
+    *fps_denom = 1;
+  }
+}
+
+/******************************************************
+ * gst_v4l2src_force_720p_30
+ *****************************************************/
+gboolean gst_v4l2_force_720p_30 (GstV4l2Src * v4l2src)
+{
+  gint fd = v4l2src->v4l2object->video_fd;
+  struct v4l2_standard   stdinfo;        
+  struct v4l2_streamparm streamparam, streamparam_s;
+  gboolean                   found;
+
+  stdinfo.index = 0;
+  found = 0;
+  while ( 0 == ioctl(fd, VIDIOC_ENUMSTD, &stdinfo)) {
+    if (stdinfo.id == V4L2_STD_720P_60) {
+        found = 1;
+        break;
+    }
+    stdinfo.index++;
+  }
+
+  if (found) {
+    /* set the streaming parameter to reduce the capture frequency to half */
+    streamparam.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    streamparam.parm.capture.timeperframe.numerator = 
+        stdinfo.frameperiod.numerator;
+    streamparam.parm.capture.timeperframe.denominator =
+        stdinfo.frameperiod.denominator / 2;    
+    streamparam_s = streamparam;
+    if (ioctl(fd, VIDIOC_S_PARM , &streamparam) < 0 ) {
+        GST_ERROR("failed to VIDIOC_S_PARM\n");
+        return FALSE;
+    }
+
+    /* verify the params */
+    if (ioctl(fd, VIDIOC_G_PARM, &streamparam) < 0) {
+        GST_ERROR("VIDIOC_G_PARM failed\n");
+        return FALSE;
+    }
+
+    if ((streamparam.parm.capture.timeperframe.numerator != 
+        streamparam_s.parm.capture.timeperframe.numerator) ||
+        (streamparam.parm.capture.timeperframe.denominator !=
+            streamparam_s.parm.capture.timeperframe.denominator)) {
+            GST_ERROR("Could not set capture driver for 30fps\n");
+            return FALSE;            
+    }
+  }
+
+  GST_ELEMENT_WARNING(v4l2src, RESOURCE, WRITE, ("forcing from 720P @60fps to "
+    "720P @30fps\n"), (NULL));
+  return TRUE;
+}
+
+#endif /* MVL_LSP */
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2src_mvl_lsp.h gst-plugins-good-0.10.31/sys/v4l2/v4l2src_mvl_lsp.h
--- gst-plugins-good-0.10.31.orig/sys/v4l2/v4l2src_mvl_lsp.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/v4l2src_mvl_lsp.h	2013-09-27 15:53:48.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * v4l2src_mvl_lsp.h
+ *
+ * This file defines functions needed to get v4l2src on dm6446, dm355, dm6467
+ * , dm357 and dm365 LSP's.
+ *
+ * Most the code is copied from DMAI capture routines with following license:
+ *
+ * --COPYRIGHT--,BSD
+ * Copyright (c) 2009, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+
+#ifndef __V4L2SRC_MVL_LSP_H__
+#define __V4L2SRC_MVL_LSP_H__
+
+#include <gstv4l2object.h>
+#include "v4l2src_calls.h"
+
+void  gst_v4l2src_get_resolution (GstV4l2Object *v4l2object, gint *width, 
+ gint *height, gint *fps_num, gint *fps_denom);
+gboolean gst_v4l2_force_720p_30 (GstV4l2Src * v4l2src);
+
+#endif /* __V4L2SRC_MVL_LSP_H__ */
+
diff -rupN gst-plugins-good-0.10.31.orig/sys/v4l2/videodev2.h gst-plugins-good-0.10.31/sys/v4l2/videodev2.h
--- gst-plugins-good-0.10.31.orig/sys/v4l2/videodev2.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-plugins-good-0.10.31/sys/v4l2/videodev2.h	2013-09-28 01:07:53.000000000 +0200
@@ -0,0 +1,1647 @@
+/*
+ *  Video for Linux Two header file
+ *
+ *  Copyright (C) 1999-2007 the contributors
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Alternatively you can redistribute this file under the terms of the
+ *  BSD license as stated below:
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *  3. The names of its contributors may not be used to endorse or promote
+ *     products derived from this software without specific prior written
+ *     permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *	Header file for v4l or V4L2 drivers and applications
+ * with public API.
+ * All kernel-specific stuff were moved to media/v4l2-dev.h, so
+ * no #if __KERNEL tests are allowed here
+ *
+ *	See http://linuxtv.org for more info
+ *
+ *	Author: Bill Dirks <bill@thedirks.org>
+ *		Justin Schoeman
+ *              Hans Verkuil <hverkuil@xs4all.nl>
+ *		et al.
+ */
+#ifndef __LINUX_VIDEODEV2_H
+#define __LINUX_VIDEODEV2_H
+
+#ifdef __KERNEL__
+#include <linux/time.h>     /* need struct timeval */
+#else
+#include <sys/time.h>
+#endif
+#include <linux/compiler.h>
+#include <linux/ioctl.h>
+//#include <linux/types.h>
+typedef unsigned char __u8;
+typedef unsigned short __u16;
+typedef unsigned long  __u32;
+typedef unsigned long  __le32;
+typedef unsigned long long __u64;
+
+typedef char  __s8;
+typedef short __s16;
+typedef long  __s32;
+typedef long long __s64;
+
+/*
+ * Common stuff for both V4L1 and V4L2
+ * Moved from videodev.h
+ */
+#define VIDEO_MAX_FRAME               32
+
+#ifndef __KERNEL__
+
+/* These defines are V4L1 specific and should not be used with the V4L2 API!
+   They will be removed from this header in the future. */
+
+#define VID_TYPE_CAPTURE	1	/* Can capture */
+#define VID_TYPE_TUNER		2	/* Can tune */
+#define VID_TYPE_TELETEXT	4	/* Does teletext */
+#define VID_TYPE_OVERLAY	8	/* Overlay onto frame buffer */
+#define VID_TYPE_CHROMAKEY	16	/* Overlay by chromakey */
+#define VID_TYPE_CLIPPING	32	/* Can clip */
+#define VID_TYPE_FRAMERAM	64	/* Uses the frame buffer memory */
+#define VID_TYPE_SCALES		128	/* Scalable */
+#define VID_TYPE_MONOCHROME	256	/* Monochrome only */
+#define VID_TYPE_SUBCAPTURE	512	/* Can capture subareas of the image */
+#define VID_TYPE_MPEG_DECODER	1024	/* Can decode MPEG streams */
+#define VID_TYPE_MPEG_ENCODER	2048	/* Can encode MPEG streams */
+#define VID_TYPE_MJPEG_DECODER	4096	/* Can decode MJPEG streams */
+#define VID_TYPE_MJPEG_ENCODER	8192	/* Can encode MJPEG streams */
+#endif
+
+/*
+ *	M I S C E L L A N E O U S
+ */
+
+/*  Four-character-code (FOURCC) */
+#define v4l2_fourcc(a, b, c, d)\
+	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
+
+/*
+ *	E N U M S
+ */
+enum v4l2_field {
+	V4L2_FIELD_ANY           = 0, /* driver can choose from none,
+					 top, bottom, interlaced
+					 depending on whatever it thinks
+					 is approximate ... */
+	V4L2_FIELD_NONE          = 1, /* this device has no fields ... */
+	V4L2_FIELD_TOP           = 2, /* top field only */
+	V4L2_FIELD_BOTTOM        = 3, /* bottom field only */
+	V4L2_FIELD_INTERLACED    = 4, /* both fields interlaced */
+	V4L2_FIELD_SEQ_TB        = 5, /* both fields sequential into one
+					 buffer, top-bottom order */
+	V4L2_FIELD_SEQ_BT        = 6, /* same as above + bottom-top order */
+	V4L2_FIELD_ALTERNATE     = 7, /* both fields alternating into
+					 separate buffers */
+	V4L2_FIELD_INTERLACED_TB = 8, /* both fields interlaced, top field
+					 first and the top field is
+					 transmitted first */
+	V4L2_FIELD_INTERLACED_BT = 9, /* both fields interlaced, top field
+					 first and the bottom field is
+					 transmitted first */
+};
+#define V4L2_FIELD_HAS_TOP(field)	\
+	((field) == V4L2_FIELD_TOP 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_INTERLACED_TB ||\
+	 (field) == V4L2_FIELD_INTERLACED_BT ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTTOM(field)	\
+	((field) == V4L2_FIELD_BOTTOM 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_INTERLACED_TB ||\
+	 (field) == V4L2_FIELD_INTERLACED_BT ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTH(field)	\
+	((field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_INTERLACED_TB ||\
+	 (field) == V4L2_FIELD_INTERLACED_BT ||\
+	 (field) == V4L2_FIELD_SEQ_TB ||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+
+enum v4l2_buf_type {
+	V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
+	V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2,
+	V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3,
+	V4L2_BUF_TYPE_VBI_CAPTURE          = 4,
+	V4L2_BUF_TYPE_VBI_OUTPUT           = 5,
+	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = 6,
+	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = 7,
+#if 1
+	/* Experimental */
+	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
+#endif
+	V4L2_BUF_TYPE_PRIVATE              = 0x80,
+};
+
+enum v4l2_ctrl_type {
+	V4L2_CTRL_TYPE_INTEGER	     = 1,
+	V4L2_CTRL_TYPE_BOOLEAN	     = 2,
+	V4L2_CTRL_TYPE_MENU	     = 3,
+	V4L2_CTRL_TYPE_BUTTON	     = 4,
+	V4L2_CTRL_TYPE_INTEGER64     = 5,
+	V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
+	V4L2_CTRL_TYPE_STRING        = 7,
+};
+
+enum v4l2_tuner_type {
+	V4L2_TUNER_RADIO	     = 1,
+	V4L2_TUNER_ANALOG_TV	     = 2,
+	V4L2_TUNER_DIGITAL_TV	     = 3,
+};
+
+enum v4l2_memory {
+	V4L2_MEMORY_MMAP             = 1,
+	V4L2_MEMORY_USERPTR          = 2,
+	V4L2_MEMORY_OVERLAY          = 3,
+};
+
+/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
+enum v4l2_colorspace {
+	/* ITU-R 601 -- broadcast NTSC/PAL */
+	V4L2_COLORSPACE_SMPTE170M     = 1,
+
+	/* 1125-Line (US) HDTV */
+	V4L2_COLORSPACE_SMPTE240M     = 2,
+
+	/* HD and modern captures. */
+	V4L2_COLORSPACE_REC709        = 3,
+
+	/* broken BT878 extents (601, luma range 16-253 instead of 16-235) */
+	V4L2_COLORSPACE_BT878         = 4,
+
+	/* These should be useful.  Assume 601 extents. */
+	V4L2_COLORSPACE_470_SYSTEM_M  = 5,
+	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
+
+	/* I know there will be cameras that send this.  So, this is
+	 * unspecified chromaticities and full 0-255 on each of the
+	 * Y'CbCr components
+	 */
+	V4L2_COLORSPACE_JPEG          = 7,
+
+	/* For RGB colourspaces, this is probably a good start. */
+	V4L2_COLORSPACE_SRGB          = 8,
+};
+
+enum v4l2_priority {
+	V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
+	V4L2_PRIORITY_BACKGROUND  = 1,
+	V4L2_PRIORITY_INTERACTIVE = 2,
+	V4L2_PRIORITY_RECORD      = 3,
+	V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
+};
+
+struct v4l2_rect {
+	__s32   left;
+	__s32   top;
+	__s32   width;
+	__s32   height;
+};
+
+struct v4l2_fract {
+	__u32   numerator;
+	__u32   denominator;
+};
+
+/*
+ *	D R I V E R   C A P A B I L I T I E S
+ */
+struct v4l2_capability {
+	__u8	driver[16];	/* i.e. "bttv" */
+	__u8	card[32];	/* i.e. "Hauppauge WinTV" */
+	__u8	bus_info[32];	/* "PCI:" + pci_name(pci_dev) */
+	__u32   version;        /* should use KERNEL_VERSION() */
+	__u32	capabilities;	/* Device capabilities */
+	__u32	reserved[4];
+};
+
+/* Values for 'capabilities' field */
+#define V4L2_CAP_VIDEO_CAPTURE		0x00000001  /* Is a video capture device */
+#define V4L2_CAP_VIDEO_OUTPUT		0x00000002  /* Is a video output device */
+#define V4L2_CAP_VIDEO_OVERLAY		0x00000004  /* Can do video overlay */
+#define V4L2_CAP_VBI_CAPTURE		0x00000010  /* Is a raw VBI capture device */
+#define V4L2_CAP_VBI_OUTPUT		0x00000020  /* Is a raw VBI output device */
+#define V4L2_CAP_SLICED_VBI_CAPTURE	0x00000040  /* Is a sliced VBI capture device */
+#define V4L2_CAP_SLICED_VBI_OUTPUT	0x00000080  /* Is a sliced VBI output device */
+#define V4L2_CAP_RDS_CAPTURE		0x00000100  /* RDS data capture */
+#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY	0x00000200  /* Can do video output overlay */
+#define V4L2_CAP_HW_FREQ_SEEK		0x00000400  /* Can do hardware frequency seek  */
+#define V4L2_CAP_RDS_OUTPUT		0x00000800  /* Is an RDS encoder */
+
+#define V4L2_CAP_TUNER			0x00010000  /* has a tuner */
+#define V4L2_CAP_AUDIO			0x00020000  /* has audio support */
+#define V4L2_CAP_RADIO			0x00040000  /* is a radio device */
+#define V4L2_CAP_MODULATOR		0x00080000  /* has a modulator */
+
+#define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
+#define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
+#define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */
+
+/*
+ *	V I D E O   I M A G E   F O R M A T
+ */
+struct v4l2_pix_format {
+	__u32         		width;
+	__u32			height;
+	__u32			pixelformat;
+	enum v4l2_field  	field;
+	__u32            	bytesperline;	/* for padding, zero if unused */
+	__u32          		sizeimage;
+	enum v4l2_colorspace	colorspace;
+	__u32			priv;		/* private data, depends on pixelformat */
+};
+
+/*      Pixel format         FOURCC                          depth  Description  */
+
+/* RGB formats */
+#define V4L2_PIX_FMT_RGB332  v4l2_fourcc('R', 'G', 'B', '1') /*  8  RGB-3-3-2     */
+#define V4L2_PIX_FMT_RGB444  v4l2_fourcc('R', '4', '4', '4') /* 16  xxxxrrrr ggggbbbb */
+#define V4L2_PIX_FMT_RGB555  v4l2_fourcc('R', 'G', 'B', 'O') /* 16  RGB-5-5-5     */
+#define V4L2_PIX_FMT_RGB565  v4l2_fourcc('R', 'G', 'B', 'P') /* 16  RGB-5-6-5     */
+#define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R', 'G', 'B', 'Q') /* 16  RGB-5-5-5 BE  */
+#define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R', 'G', 'B', 'R') /* 16  RGB-5-6-5 BE  */
+#define V4L2_PIX_FMT_BGR24   v4l2_fourcc('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
+#define V4L2_PIX_FMT_RGB24   v4l2_fourcc('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
+#define V4L2_PIX_FMT_BGR32   v4l2_fourcc('B', 'G', 'R', '4') /* 32  BGR-8-8-8-8   */
+#define V4L2_PIX_FMT_RGB32   v4l2_fourcc('R', 'G', 'B', '4') /* 32  RGB-8-8-8-8   */
+
+/* Grey formats */
+#define V4L2_PIX_FMT_GREY    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
+#define V4L2_PIX_FMT_Y16     v4l2_fourcc('Y', '1', '6', ' ') /* 16  Greyscale     */
+
+/* Palette formats */
+#define V4L2_PIX_FMT_PAL8    v4l2_fourcc('P', 'A', 'L', '8') /*  8  8-bit palette */
+
+/* Luminance+Chrominance formats */
+#define V4L2_PIX_FMT_YVU410  v4l2_fourcc('Y', 'V', 'U', '9') /*  9  YVU 4:1:0     */
+#define V4L2_PIX_FMT_YVU420  v4l2_fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
+#define V4L2_PIX_FMT_YUYV    v4l2_fourcc('Y', 'U', 'Y', 'V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YYUV    v4l2_fourcc('Y', 'Y', 'U', 'V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YVYU    v4l2_fourcc('Y', 'V', 'Y', 'U') /* 16 YVU 4:2:2 */
+#define V4L2_PIX_FMT_UYVY    v4l2_fourcc('U', 'Y', 'V', 'Y') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_VYUY    v4l2_fourcc('V', 'Y', 'U', 'Y') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YUV422P v4l2_fourcc('4', '2', '2', 'P') /* 16  YVU422 planar */
+#define V4L2_PIX_FMT_YUV411P v4l2_fourcc('4', '1', '1', 'P') /* 16  YVU411 planar */
+#define V4L2_PIX_FMT_Y41P    v4l2_fourcc('Y', '4', '1', 'P') /* 12  YUV 4:1:1     */
+#define V4L2_PIX_FMT_YUV444  v4l2_fourcc('Y', '4', '4', '4') /* 16  xxxxyyyy uuuuvvvv */
+#define V4L2_PIX_FMT_YUV555  v4l2_fourcc('Y', 'U', 'V', 'O') /* 16  YUV-5-5-5     */
+#define V4L2_PIX_FMT_YUV565  v4l2_fourcc('Y', 'U', 'V', 'P') /* 16  YUV-5-6-5     */
+#define V4L2_PIX_FMT_YUV32   v4l2_fourcc('Y', 'U', 'V', '4') /* 32  YUV-8-8-8-8   */
+#define V4L2_PIX_FMT_YUV410  v4l2_fourcc('Y', 'U', 'V', '9') /*  9  YUV 4:1:0     */
+#define V4L2_PIX_FMT_YUV420  v4l2_fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
+#define V4L2_PIX_FMT_HI240   v4l2_fourcc('H', 'I', '2', '4') /*  8  8-bit color   */
+#define V4L2_PIX_FMT_HM12    v4l2_fourcc('H', 'M', '1', '2') /*  8  YUV 4:2:0 16x16 macroblocks */
+
+/* two planes -- one Y, one Cr + Cb interleaved  */
+#define V4L2_PIX_FMT_NV12    v4l2_fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define V4L2_PIX_FMT_NV21    v4l2_fourcc('N', 'V', '2', '1') /* 12  Y/CrCb 4:2:0  */
+#define V4L2_PIX_FMT_NV16    v4l2_fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
+#define V4L2_PIX_FMT_NV61    v4l2_fourcc('N', 'V', '6', '1') /* 16  Y/CrCb 4:2:2  */
+
+/* Bayer formats - see http://www.siliconimaging.com/RGB%20Bayer.htm */
+#define V4L2_PIX_FMT_SBGGR8  v4l2_fourcc('B', 'A', '8', '1') /*  8  BGBG.. GRGR.. */
+#define V4L2_PIX_FMT_SGBRG8  v4l2_fourcc('G', 'B', 'R', 'G') /*  8  GBGB.. RGRG.. */
+#define V4L2_PIX_FMT_SGRBG8  v4l2_fourcc('G', 'R', 'B', 'G') /*  8  GRGR.. BGBG.. */
+#define V4L2_PIX_FMT_SGRBG10 v4l2_fourcc('B', 'A', '1', '0') /* 10bit raw bayer */
+	/* 10bit raw bayer DPCM compressed to 8 bits */
+#define V4L2_PIX_FMT_SGRBG10DPCM8 v4l2_fourcc('B', 'D', '1', '0')
+	/*
+	 * 10bit raw bayer, expanded to 16 bits
+	 * xxxxrrrrrrrrrrxxxxgggggggggg xxxxggggggggggxxxxbbbbbbbbbb...
+	 */
+#define V4L2_PIX_FMT_SBGGR16 v4l2_fourcc('B', 'Y', 'R', '2') /* 16  BGBG.. GRGR.. */
+
+/* compressed formats */
+#define V4L2_PIX_FMT_MJPEG    v4l2_fourcc('M', 'J', 'P', 'G') /* Motion-JPEG   */
+#define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
+#define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
+#define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4    */
+
+/*  Vendor-specific formats   */
+#define V4L2_PIX_FMT_WNVA     v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
+#define V4L2_PIX_FMT_SN9C10X  v4l2_fourcc('S', '9', '1', '0') /* SN9C10x compression */
+#define V4L2_PIX_FMT_SN9C20X_I420 v4l2_fourcc('S', '9', '2', '0') /* SN9C20x YUV 4:2:0 */
+#define V4L2_PIX_FMT_PWC1     v4l2_fourcc('P', 'W', 'C', '1') /* pwc older webcam */
+#define V4L2_PIX_FMT_PWC2     v4l2_fourcc('P', 'W', 'C', '2') /* pwc newer webcam */
+#define V4L2_PIX_FMT_ET61X251 v4l2_fourcc('E', '6', '2', '5') /* ET61X251 compression */
+#define V4L2_PIX_FMT_SPCA501  v4l2_fourcc('S', '5', '0', '1') /* YUYV per line */
+#define V4L2_PIX_FMT_SPCA505  v4l2_fourcc('S', '5', '0', '5') /* YYUV per line */
+#define V4L2_PIX_FMT_SPCA508  v4l2_fourcc('S', '5', '0', '8') /* YUVY per line */
+#define V4L2_PIX_FMT_SPCA561  v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
+#define V4L2_PIX_FMT_PAC207   v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
+#define V4L2_PIX_FMT_MR97310A v4l2_fourcc('M', '3', '1', '0') /* compressed BGGR bayer */
+#define V4L2_PIX_FMT_SQ905C   v4l2_fourcc('9', '0', '5', 'C') /* compressed RGGB bayer */
+#define V4L2_PIX_FMT_PJPG     v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
+#define V4L2_PIX_FMT_OV511    v4l2_fourcc('O', '5', '1', '1') /* ov511 JPEG */
+#define V4L2_PIX_FMT_OV518    v4l2_fourcc('O', '5', '1', '8') /* ov518 JPEG */
+
+/*
+ *	F O R M A T   E N U M E R A T I O N
+ */
+struct v4l2_fmtdesc {
+	__u32		    index;             /* Format number      */
+	enum v4l2_buf_type  type;              /* buffer type        */
+	__u32               flags;
+	__u8		    description[32];   /* Description string */
+	__u32		    pixelformat;       /* Format fourcc      */
+	__u32		    reserved[4];
+};
+
+#define V4L2_FMT_FLAG_COMPRESSED 0x0001
+#define V4L2_FMT_FLAG_EMULATED   0x0002
+
+#if 1
+	/* Experimental Frame Size and frame rate enumeration */
+/*
+ *	F R A M E   S I Z E   E N U M E R A T I O N
+ */
+enum v4l2_frmsizetypes {
+	V4L2_FRMSIZE_TYPE_DISCRETE	= 1,
+	V4L2_FRMSIZE_TYPE_CONTINUOUS	= 2,
+	V4L2_FRMSIZE_TYPE_STEPWISE	= 3,
+};
+
+struct v4l2_frmsize_discrete {
+	__u32			width;		/* Frame width [pixel] */
+	__u32			height;		/* Frame height [pixel] */
+};
+
+struct v4l2_frmsize_stepwise {
+	__u32			min_width;	/* Minimum frame width [pixel] */
+	__u32			max_width;	/* Maximum frame width [pixel] */
+	__u32			step_width;	/* Frame width step size [pixel] */
+	__u32			min_height;	/* Minimum frame height [pixel] */
+	__u32			max_height;	/* Maximum frame height [pixel] */
+	__u32			step_height;	/* Frame height step size [pixel] */
+};
+
+struct v4l2_frmsizeenum {
+	__u32			index;		/* Frame size number */
+	__u32			pixel_format;	/* Pixel format */
+	__u32			type;		/* Frame size type the device supports. */
+
+	union {					/* Frame size */
+		struct v4l2_frmsize_discrete	discrete;
+		struct v4l2_frmsize_stepwise	stepwise;
+	};
+
+	__u32   reserved[2];			/* Reserved space for future use */
+};
+
+/*
+ *	F R A M E   R A T E   E N U M E R A T I O N
+ */
+enum v4l2_frmivaltypes {
+	V4L2_FRMIVAL_TYPE_DISCRETE	= 1,
+	V4L2_FRMIVAL_TYPE_CONTINUOUS	= 2,
+	V4L2_FRMIVAL_TYPE_STEPWISE	= 3,
+};
+
+struct v4l2_frmival_stepwise {
+	struct v4l2_fract	min;		/* Minimum frame interval [s] */
+	struct v4l2_fract	max;		/* Maximum frame interval [s] */
+	struct v4l2_fract	step;		/* Frame interval step size [s] */
+};
+
+struct v4l2_frmivalenum {
+	__u32			index;		/* Frame format index */
+	__u32			pixel_format;	/* Pixel format */
+	__u32			width;		/* Frame width */
+	__u32			height;		/* Frame height */
+	__u32			type;		/* Frame interval type the device supports. */
+
+	union {					/* Frame interval */
+		struct v4l2_fract		discrete;
+		struct v4l2_frmival_stepwise	stepwise;
+	};
+
+	__u32	reserved[2];			/* Reserved space for future use */
+};
+#endif
+
+/*
+ *	T I M E C O D E
+ */
+struct v4l2_timecode {
+	__u32	type;
+	__u32	flags;
+	__u8	frames;
+	__u8	seconds;
+	__u8	minutes;
+	__u8	hours;
+	__u8	userbits[4];
+};
+
+/*  Type  */
+#define V4L2_TC_TYPE_24FPS		1
+#define V4L2_TC_TYPE_25FPS		2
+#define V4L2_TC_TYPE_30FPS		3
+#define V4L2_TC_TYPE_50FPS		4
+#define V4L2_TC_TYPE_60FPS		5
+
+/*  Flags  */
+#define V4L2_TC_FLAG_DROPFRAME		0x0001 /* "drop-frame" mode */
+#define V4L2_TC_FLAG_COLORFRAME		0x0002
+#define V4L2_TC_USERBITS_field		0x000C
+#define V4L2_TC_USERBITS_USERDEFINED	0x0000
+#define V4L2_TC_USERBITS_8BITCHARS	0x0008
+/* The above is based on SMPTE timecodes */
+
+struct v4l2_jpegcompression {
+	int quality;
+
+	int  APPn;              /* Number of APP segment to be written,
+				 * must be 0..15 */
+	int  APP_len;           /* Length of data in JPEG APPn segment */
+	char APP_data[60];      /* Data in the JPEG APPn segment. */
+
+	int  COM_len;           /* Length of data in JPEG COM segment */
+	char COM_data[60];      /* Data in JPEG COM segment */
+
+	__u32 jpeg_markers;     /* Which markers should go into the JPEG
+				 * output. Unless you exactly know what
+				 * you do, leave them untouched.
+				 * Inluding less markers will make the
+				 * resulting code smaller, but there will
+				 * be fewer aplications which can read it.
+				 * The presence of the APP and COM marker
+				 * is influenced by APP_len and COM_len
+				 * ONLY, not by this property! */
+
+#define V4L2_JPEG_MARKER_DHT (1<<3)    /* Define Huffman Tables */
+#define V4L2_JPEG_MARKER_DQT (1<<4)    /* Define Quantization Tables */
+#define V4L2_JPEG_MARKER_DRI (1<<5)    /* Define Restart Interval */
+#define V4L2_JPEG_MARKER_COM (1<<6)    /* Comment segment */
+#define V4L2_JPEG_MARKER_APP (1<<7)    /* App segment, driver will
+					* allways use APP0 */
+};
+
+/*
+ *	M E M O R Y - M A P P I N G   B U F F E R S
+ */
+struct v4l2_requestbuffers {
+	__u32			count;
+	enum v4l2_buf_type      type;
+	enum v4l2_memory        memory;
+	__u32			reserved[2];
+};
+
+struct v4l2_buffer {
+	__u32			index;
+	enum v4l2_buf_type      type;
+	__u32			bytesused;
+	__u32			flags;
+	enum v4l2_field		field;
+	struct timeval		timestamp;
+	struct v4l2_timecode	timecode;
+	__u32			sequence;
+
+	/* memory location */
+	enum v4l2_memory        memory;
+	union {
+		__u32           offset;
+		unsigned long   userptr;
+	} m;
+	__u32			length;
+	__u32			input;
+	__u32			reserved;
+};
+
+/*  Flags for 'flags' field */
+#define V4L2_BUF_FLAG_MAPPED	0x0001  /* Buffer is mapped (flag) */
+#define V4L2_BUF_FLAG_QUEUED	0x0002	/* Buffer is queued for processing */
+#define V4L2_BUF_FLAG_DONE	0x0004	/* Buffer is ready */
+#define V4L2_BUF_FLAG_KEYFRAME	0x0008	/* Image is a keyframe (I-frame) */
+#define V4L2_BUF_FLAG_PFRAME	0x0010	/* Image is a P-frame */
+#define V4L2_BUF_FLAG_BFRAME	0x0020	/* Image is a B-frame */
+#define V4L2_BUF_FLAG_TIMECODE	0x0100	/* timecode field is valid */
+#define V4L2_BUF_FLAG_INPUT     0x0200  /* input field is valid */
+
+/*
+ *	O V E R L A Y   P R E V I E W
+ */
+struct v4l2_framebuffer {
+	__u32			capability;
+	__u32			flags;
+/* FIXME: in theory we should pass something like PCI device + memory
+ * region + offset instead of some physical address */
+	void                    *base;
+	struct v4l2_pix_format	fmt;
+};
+/*  Flags for the 'capability' field. Read only */
+#define V4L2_FBUF_CAP_EXTERNOVERLAY	0x0001
+#define V4L2_FBUF_CAP_CHROMAKEY		0x0002
+#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
+#define V4L2_FBUF_CAP_BITMAP_CLIPPING	0x0008
+#define V4L2_FBUF_CAP_LOCAL_ALPHA	0x0010
+#define V4L2_FBUF_CAP_GLOBAL_ALPHA	0x0020
+#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA	0x0040
+/*  Flags for the 'flags' field. */
+#define V4L2_FBUF_FLAG_PRIMARY		0x0001
+#define V4L2_FBUF_FLAG_OVERLAY		0x0002
+#define V4L2_FBUF_FLAG_CHROMAKEY	0x0004
+#define V4L2_FBUF_FLAG_LOCAL_ALPHA	0x0008
+#define V4L2_FBUF_FLAG_GLOBAL_ALPHA	0x0010
+#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA	0x0020
+
+struct v4l2_clip {
+	struct v4l2_rect        c;
+	struct v4l2_clip	__user *next;
+};
+
+struct v4l2_window {
+	struct v4l2_rect        w;
+	enum v4l2_field  	field;
+	__u32			chromakey;
+	struct v4l2_clip	__user *clips;
+	__u32			clipcount;
+	void			__user *bitmap;
+	__u8                    global_alpha;
+};
+
+/*
+ *	C A P T U R E   P A R A M E T E R S
+ */
+struct v4l2_captureparm {
+	__u32		   capability;	  /*  Supported modes */
+	__u32		   capturemode;	  /*  Current mode */
+	struct v4l2_fract  timeperframe;  /*  Time per frame in .1us units */
+	__u32		   extendedmode;  /*  Driver-specific extensions */
+	__u32              readbuffers;   /*  # of buffers for read */
+	__u32		   reserved[4];
+};
+
+/*  Flags for 'capability' and 'capturemode' fields */
+#define V4L2_MODE_HIGHQUALITY	0x0001	/*  High quality imaging mode */
+#define V4L2_CAP_TIMEPERFRAME	0x1000	/*  timeperframe field is supported */
+
+struct v4l2_outputparm {
+	__u32		   capability;	 /*  Supported modes */
+	__u32		   outputmode;	 /*  Current mode */
+	struct v4l2_fract  timeperframe; /*  Time per frame in seconds */
+	__u32		   extendedmode; /*  Driver-specific extensions */
+	__u32              writebuffers; /*  # of buffers for write */
+	__u32		   reserved[4];
+};
+
+/*
+ *	I N P U T   I M A G E   C R O P P I N G
+ */
+struct v4l2_cropcap {
+	enum v4l2_buf_type      type;
+	struct v4l2_rect        bounds;
+	struct v4l2_rect        defrect;
+	struct v4l2_fract       pixelaspect;
+};
+
+struct v4l2_crop {
+	enum v4l2_buf_type      type;
+	struct v4l2_rect        c;
+};
+
+/*
+ *      A N A L O G   V I D E O   S T A N D A R D
+ */
+
+typedef __u64 v4l2_std_id;
+
+/* one bit for each */
+#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
+#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
+#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
+#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
+#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
+#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
+#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
+#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)
+
+#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
+#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
+#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
+#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)
+
+#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
+#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
+#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
+#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)
+
+#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
+#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
+#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
+#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
+#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
+#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
+#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
+#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)
+
+/* ATSC/HDTV */
+#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
+#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)
+
+/* FIXME:
+   Although std_id is 64 bits, there is an issue on PPC32 architecture that
+   makes switch(__u64) to break. So, there's a hack on v4l2-common.c rounding
+   this value to 32 bits.
+   As, currently, the max value is for V4L2_STD_ATSC_16_VSB (30 bits wide),
+   it should work fine. However, if needed to add more than two standards,
+   v4l2-common.c should be fixed.
+ */
+
+/* some merged standards */
+#define V4L2_STD_MN	(V4L2_STD_PAL_M|V4L2_STD_PAL_N|V4L2_STD_PAL_Nc|V4L2_STD_NTSC)
+#define V4L2_STD_B	(V4L2_STD_PAL_B|V4L2_STD_PAL_B1|V4L2_STD_SECAM_B)
+#define V4L2_STD_GH	(V4L2_STD_PAL_G|V4L2_STD_PAL_H|V4L2_STD_SECAM_G|V4L2_STD_SECAM_H)
+#define V4L2_STD_DK	(V4L2_STD_PAL_DK|V4L2_STD_SECAM_DK)
+
+/* some common needed stuff */
+#define V4L2_STD_PAL_BG		(V4L2_STD_PAL_B		|\
+				 V4L2_STD_PAL_B1	|\
+				 V4L2_STD_PAL_G)
+#define V4L2_STD_PAL_DK		(V4L2_STD_PAL_D		|\
+				 V4L2_STD_PAL_D1	|\
+				 V4L2_STD_PAL_K)
+#define V4L2_STD_PAL		(V4L2_STD_PAL_BG	|\
+				 V4L2_STD_PAL_DK	|\
+				 V4L2_STD_PAL_H		|\
+				 V4L2_STD_PAL_I)
+#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M	|\
+				 V4L2_STD_NTSC_M_JP     |\
+				 V4L2_STD_NTSC_M_KR)
+#define V4L2_STD_SECAM_DK      	(V4L2_STD_SECAM_D	|\
+				 V4L2_STD_SECAM_K	|\
+				 V4L2_STD_SECAM_K1)
+#define V4L2_STD_SECAM		(V4L2_STD_SECAM_B	|\
+				 V4L2_STD_SECAM_G	|\
+				 V4L2_STD_SECAM_H	|\
+				 V4L2_STD_SECAM_DK	|\
+				 V4L2_STD_SECAM_L       |\
+				 V4L2_STD_SECAM_LC)
+
+#define V4L2_STD_525_60		(V4L2_STD_PAL_M		|\
+				 V4L2_STD_PAL_60	|\
+				 V4L2_STD_NTSC		|\
+				 V4L2_STD_NTSC_443)
+#define V4L2_STD_625_50		(V4L2_STD_PAL		|\
+				 V4L2_STD_PAL_N		|\
+				 V4L2_STD_PAL_Nc	|\
+				 V4L2_STD_SECAM)
+#define V4L2_STD_ATSC           (V4L2_STD_ATSC_8_VSB    |\
+				 V4L2_STD_ATSC_16_VSB)
+
+#define V4L2_STD_UNKNOWN        0
+#define V4L2_STD_ALL            (V4L2_STD_525_60	|\
+				 V4L2_STD_625_50)
+
+struct v4l2_standard {
+	__u32		     index;
+	v4l2_std_id          id;
+	__u8		     name[24];
+	struct v4l2_fract    frameperiod; /* Frames, not fields */
+	__u32		     framelines;
+	__u32		     reserved[4];
+};
+
+/*
+ *	V I D E O   I N P U T S
+ */
+struct v4l2_input {
+	__u32	     index;		/*  Which input */
+	__u8	     name[32];		/*  Label */
+	__u32	     type;		/*  Type of input */
+	__u32	     audioset;		/*  Associated audios (bitfield) */
+	__u32        tuner;             /*  Associated tuner */
+	v4l2_std_id  std;
+	__u32	     status;
+	__u32	     reserved[4];
+};
+
+/*  Values for the 'type' field */
+#define V4L2_INPUT_TYPE_TUNER		1
+#define V4L2_INPUT_TYPE_CAMERA		2
+
+/* field 'status' - general */
+#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
+#define V4L2_IN_ST_NO_SIGNAL   0x00000002
+#define V4L2_IN_ST_NO_COLOR    0x00000004
+
+/* field 'status' - sensor orientation */
+/* If sensor is mounted upside down set both bits */
+#define V4L2_IN_ST_HFLIP       0x00000010 /* Frames are flipped horizontally */
+#define V4L2_IN_ST_VFLIP       0x00000020 /* Frames are flipped vertically */
+
+/* field 'status' - analog */
+#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
+#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */
+
+/* field 'status' - digital */
+#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
+#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
+#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */
+
+/* field 'status' - VCR and set-top box */
+#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
+#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
+#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */
+
+/*
+ *	V I D E O   O U T P U T S
+ */
+struct v4l2_output {
+	__u32	     index;		/*  Which output */
+	__u8	     name[32];		/*  Label */
+	__u32	     type;		/*  Type of output */
+	__u32	     audioset;		/*  Associated audios (bitfield) */
+	__u32	     modulator;         /*  Associated modulator */
+	v4l2_std_id  std;
+	__u32	     reserved[4];
+};
+/*  Values for the 'type' field */
+#define V4L2_OUTPUT_TYPE_MODULATOR		1
+#define V4L2_OUTPUT_TYPE_ANALOG			2
+#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY	3
+
+/*
+ *	C O N T R O L S
+ */
+struct v4l2_control {
+	__u32		     id;
+	__s32		     value;
+};
+
+struct v4l2_ext_control {
+	__u32 id;
+	__u32 size;
+	__u32 reserved2[1];
+	union {
+		__s32 value;
+		__s64 value64;
+		char *string;
+	};
+} __attribute__ ((packed));
+
+struct v4l2_ext_controls {
+	__u32 ctrl_class;
+	__u32 count;
+	__u32 error_idx;
+	__u32 reserved[2];
+	struct v4l2_ext_control *controls;
+};
+
+/*  Values for ctrl_class field */
+#define V4L2_CTRL_CLASS_USER 0x00980000	/* Old-style 'user' controls */
+#define V4L2_CTRL_CLASS_MPEG 0x00990000	/* MPEG-compression controls */
+#define V4L2_CTRL_CLASS_CAMERA 0x009a0000	/* Camera class controls */
+#define V4L2_CTRL_CLASS_FM_TX 0x009b0000	/* FM Modulator control class */
+
+#define V4L2_CTRL_ID_MASK      	  (0x0fffffff)
+#define V4L2_CTRL_ID2CLASS(id)    ((id) & 0x0fff0000UL)
+#define V4L2_CTRL_DRIVER_PRIV(id) (((id) & 0xffff) >= 0x1000)
+
+/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
+struct v4l2_queryctrl {
+	__u32		     id;
+	enum v4l2_ctrl_type  type;
+	__u8		     name[32];	/* Whatever */
+	__s32		     minimum;	/* Note signedness */
+	__s32		     maximum;
+	__s32		     step;
+	__s32		     default_value;
+	__u32                flags;
+	__u32		     reserved[2];
+};
+
+/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
+struct v4l2_querymenu {
+	__u32		id;
+	__u32		index;
+	__u8		name[32];	/* Whatever */
+	__u32		reserved;
+};
+
+/*  Control flags  */
+#define V4L2_CTRL_FLAG_DISABLED		0x0001
+#define V4L2_CTRL_FLAG_GRABBED		0x0002
+#define V4L2_CTRL_FLAG_READ_ONLY 	0x0004
+#define V4L2_CTRL_FLAG_UPDATE 		0x0008
+#define V4L2_CTRL_FLAG_INACTIVE 	0x0010
+#define V4L2_CTRL_FLAG_SLIDER 		0x0020
+#define V4L2_CTRL_FLAG_WRITE_ONLY 	0x0040
+
+/*  Query flag, to be ORed with the control ID */
+#define V4L2_CTRL_FLAG_NEXT_CTRL	0x80000000
+
+/*  User-class control IDs defined by V4L2 */
+#define V4L2_CID_BASE			(V4L2_CTRL_CLASS_USER | 0x900)
+#define V4L2_CID_USER_BASE 		V4L2_CID_BASE
+/*  IDs reserved for driver specific controls */
+#define V4L2_CID_PRIVATE_BASE		0x08000000
+
+#define V4L2_CID_USER_CLASS 		(V4L2_CTRL_CLASS_USER | 1)
+#define V4L2_CID_BRIGHTNESS		(V4L2_CID_BASE+0)
+#define V4L2_CID_CONTRAST		(V4L2_CID_BASE+1)
+#define V4L2_CID_SATURATION		(V4L2_CID_BASE+2)
+#define V4L2_CID_HUE			(V4L2_CID_BASE+3)
+#define V4L2_CID_AUDIO_VOLUME		(V4L2_CID_BASE+5)
+#define V4L2_CID_AUDIO_BALANCE		(V4L2_CID_BASE+6)
+#define V4L2_CID_AUDIO_BASS		(V4L2_CID_BASE+7)
+#define V4L2_CID_AUDIO_TREBLE		(V4L2_CID_BASE+8)
+#define V4L2_CID_AUDIO_MUTE		(V4L2_CID_BASE+9)
+#define V4L2_CID_AUDIO_LOUDNESS		(V4L2_CID_BASE+10)
+#define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11) /* Deprecated */
+#define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
+#define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
+#define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
+#define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
+#define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
+#define V4L2_CID_WHITENESS		(V4L2_CID_GAMMA) /* Deprecated */
+#define V4L2_CID_EXPOSURE		(V4L2_CID_BASE+17)
+#define V4L2_CID_AUTOGAIN		(V4L2_CID_BASE+18)
+#define V4L2_CID_GAIN			(V4L2_CID_BASE+19)
+#define V4L2_CID_HFLIP			(V4L2_CID_BASE+20)
+#define V4L2_CID_VFLIP			(V4L2_CID_BASE+21)
+
+/* Deprecated; use V4L2_CID_PAN_RESET and V4L2_CID_TILT_RESET */
+#define V4L2_CID_HCENTER		(V4L2_CID_BASE+22)
+#define V4L2_CID_VCENTER		(V4L2_CID_BASE+23)
+
+#define V4L2_CID_POWER_LINE_FREQUENCY	(V4L2_CID_BASE+24)
+enum v4l2_power_line_frequency {
+	V4L2_CID_POWER_LINE_FREQUENCY_DISABLED	= 0,
+	V4L2_CID_POWER_LINE_FREQUENCY_50HZ	= 1,
+	V4L2_CID_POWER_LINE_FREQUENCY_60HZ	= 2,
+};
+#define V4L2_CID_HUE_AUTO			(V4L2_CID_BASE+25)
+#define V4L2_CID_WHITE_BALANCE_TEMPERATURE	(V4L2_CID_BASE+26)
+#define V4L2_CID_SHARPNESS			(V4L2_CID_BASE+27)
+#define V4L2_CID_BACKLIGHT_COMPENSATION 	(V4L2_CID_BASE+28)
+#define V4L2_CID_CHROMA_AGC                     (V4L2_CID_BASE+29)
+#define V4L2_CID_COLOR_KILLER                   (V4L2_CID_BASE+30)
+#define V4L2_CID_COLORFX			(V4L2_CID_BASE+31)
+enum v4l2_colorfx {
+	V4L2_COLORFX_NONE	= 0,
+	V4L2_COLORFX_BW		= 1,
+	V4L2_COLORFX_SEPIA	= 2,
+};
+#define V4L2_CID_AUTOBRIGHTNESS			(V4L2_CID_BASE+32)
+#define V4L2_CID_BAND_STOP_FILTER		(V4L2_CID_BASE+33)
+
+/* last CID + 1 */
+#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+34)
+
+/*  MPEG-class control IDs defined by V4L2 */
+#define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
+#define V4L2_CID_MPEG_CLASS 			(V4L2_CTRL_CLASS_MPEG | 1)
+
+/*  MPEG streams */
+#define V4L2_CID_MPEG_STREAM_TYPE 		(V4L2_CID_MPEG_BASE+0)
+enum v4l2_mpeg_stream_type {
+	V4L2_MPEG_STREAM_TYPE_MPEG2_PS   = 0, /* MPEG-2 program stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG2_TS   = 1, /* MPEG-2 transport stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG1_SS   = 2, /* MPEG-1 system stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG2_DVD  = 3, /* MPEG-2 DVD-compatible stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG1_VCD  = 4, /* MPEG-1 VCD-compatible stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5, /* MPEG-2 SVCD-compatible stream */
+};
+#define V4L2_CID_MPEG_STREAM_PID_PMT 		(V4L2_CID_MPEG_BASE+1)
+#define V4L2_CID_MPEG_STREAM_PID_AUDIO 		(V4L2_CID_MPEG_BASE+2)
+#define V4L2_CID_MPEG_STREAM_PID_VIDEO 		(V4L2_CID_MPEG_BASE+3)
+#define V4L2_CID_MPEG_STREAM_PID_PCR 		(V4L2_CID_MPEG_BASE+4)
+#define V4L2_CID_MPEG_STREAM_PES_ID_AUDIO 	(V4L2_CID_MPEG_BASE+5)
+#define V4L2_CID_MPEG_STREAM_PES_ID_VIDEO 	(V4L2_CID_MPEG_BASE+6)
+#define V4L2_CID_MPEG_STREAM_VBI_FMT 		(V4L2_CID_MPEG_BASE+7)
+enum v4l2_mpeg_stream_vbi_fmt {
+	V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,  /* No VBI in the MPEG stream */
+	V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,  /* VBI in private packets, IVTV format */
+};
+
+/*  MPEG audio */
+#define V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ 	(V4L2_CID_MPEG_BASE+100)
+enum v4l2_mpeg_audio_sampling_freq {
+	V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
+	V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
+	V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
+};
+#define V4L2_CID_MPEG_AUDIO_ENCODING 		(V4L2_CID_MPEG_BASE+101)
+enum v4l2_mpeg_audio_encoding {
+	V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
+	V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
+	V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
+	V4L2_MPEG_AUDIO_ENCODING_AAC     = 3,
+	V4L2_MPEG_AUDIO_ENCODING_AC3     = 4,
+};
+#define V4L2_CID_MPEG_AUDIO_L1_BITRATE 		(V4L2_CID_MPEG_BASE+102)
+enum v4l2_mpeg_audio_l1_bitrate {
+	V4L2_MPEG_AUDIO_L1_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_L1_BITRATE_64K  = 1,
+	V4L2_MPEG_AUDIO_L1_BITRATE_96K  = 2,
+	V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
+	V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
+	V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
+	V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
+	V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
+	V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
+	V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
+	V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
+	V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
+	V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
+	V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
+};
+#define V4L2_CID_MPEG_AUDIO_L2_BITRATE 		(V4L2_CID_MPEG_BASE+103)
+enum v4l2_mpeg_audio_l2_bitrate {
+	V4L2_MPEG_AUDIO_L2_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_L2_BITRATE_48K  = 1,
+	V4L2_MPEG_AUDIO_L2_BITRATE_56K  = 2,
+	V4L2_MPEG_AUDIO_L2_BITRATE_64K  = 3,
+	V4L2_MPEG_AUDIO_L2_BITRATE_80K  = 4,
+	V4L2_MPEG_AUDIO_L2_BITRATE_96K  = 5,
+	V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
+	V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
+	V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
+	V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
+	V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
+	V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
+	V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
+	V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
+};
+#define V4L2_CID_MPEG_AUDIO_L3_BITRATE 		(V4L2_CID_MPEG_BASE+104)
+enum v4l2_mpeg_audio_l3_bitrate {
+	V4L2_MPEG_AUDIO_L3_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_L3_BITRATE_40K  = 1,
+	V4L2_MPEG_AUDIO_L3_BITRATE_48K  = 2,
+	V4L2_MPEG_AUDIO_L3_BITRATE_56K  = 3,
+	V4L2_MPEG_AUDIO_L3_BITRATE_64K  = 4,
+	V4L2_MPEG_AUDIO_L3_BITRATE_80K  = 5,
+	V4L2_MPEG_AUDIO_L3_BITRATE_96K  = 6,
+	V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
+	V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
+	V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
+	V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
+	V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
+	V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
+	V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
+};
+#define V4L2_CID_MPEG_AUDIO_MODE 		(V4L2_CID_MPEG_BASE+105)
+enum v4l2_mpeg_audio_mode {
+	V4L2_MPEG_AUDIO_MODE_STEREO       = 0,
+	V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
+	V4L2_MPEG_AUDIO_MODE_DUAL         = 2,
+	V4L2_MPEG_AUDIO_MODE_MONO         = 3,
+};
+#define V4L2_CID_MPEG_AUDIO_MODE_EXTENSION 	(V4L2_CID_MPEG_BASE+106)
+enum v4l2_mpeg_audio_mode_extension {
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4  = 0,
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8  = 1,
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
+};
+#define V4L2_CID_MPEG_AUDIO_EMPHASIS 		(V4L2_CID_MPEG_BASE+107)
+enum v4l2_mpeg_audio_emphasis {
+	V4L2_MPEG_AUDIO_EMPHASIS_NONE         = 0,
+	V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
+	V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17    = 2,
+};
+#define V4L2_CID_MPEG_AUDIO_CRC 		(V4L2_CID_MPEG_BASE+108)
+enum v4l2_mpeg_audio_crc {
+	V4L2_MPEG_AUDIO_CRC_NONE  = 0,
+	V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
+};
+#define V4L2_CID_MPEG_AUDIO_MUTE 		(V4L2_CID_MPEG_BASE+109)
+#define V4L2_CID_MPEG_AUDIO_AAC_BITRATE		(V4L2_CID_MPEG_BASE+110)
+#define V4L2_CID_MPEG_AUDIO_AC3_BITRATE		(V4L2_CID_MPEG_BASE+111)
+enum v4l2_mpeg_audio_ac3_bitrate {
+	V4L2_MPEG_AUDIO_AC3_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_40K  = 1,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_48K  = 2,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_56K  = 3,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_64K  = 4,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_80K  = 5,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_96K  = 6,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18,
+};
+
+/*  MPEG video */
+#define V4L2_CID_MPEG_VIDEO_ENCODING 		(V4L2_CID_MPEG_BASE+200)
+enum v4l2_mpeg_video_encoding {
+	V4L2_MPEG_VIDEO_ENCODING_MPEG_1     = 0,
+	V4L2_MPEG_VIDEO_ENCODING_MPEG_2     = 1,
+	V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2,
+};
+#define V4L2_CID_MPEG_VIDEO_ASPECT 		(V4L2_CID_MPEG_BASE+201)
+enum v4l2_mpeg_video_aspect {
+	V4L2_MPEG_VIDEO_ASPECT_1x1     = 0,
+	V4L2_MPEG_VIDEO_ASPECT_4x3     = 1,
+	V4L2_MPEG_VIDEO_ASPECT_16x9    = 2,
+	V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
+};
+#define V4L2_CID_MPEG_VIDEO_B_FRAMES 		(V4L2_CID_MPEG_BASE+202)
+#define V4L2_CID_MPEG_VIDEO_GOP_SIZE 		(V4L2_CID_MPEG_BASE+203)
+#define V4L2_CID_MPEG_VIDEO_GOP_CLOSURE 	(V4L2_CID_MPEG_BASE+204)
+#define V4L2_CID_MPEG_VIDEO_PULLDOWN 		(V4L2_CID_MPEG_BASE+205)
+#define V4L2_CID_MPEG_VIDEO_BITRATE_MODE 	(V4L2_CID_MPEG_BASE+206)
+enum v4l2_mpeg_video_bitrate_mode {
+	V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
+	V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
+};
+#define V4L2_CID_MPEG_VIDEO_BITRATE 		(V4L2_CID_MPEG_BASE+207)
+#define V4L2_CID_MPEG_VIDEO_BITRATE_PEAK 	(V4L2_CID_MPEG_BASE+208)
+#define V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION (V4L2_CID_MPEG_BASE+209)
+#define V4L2_CID_MPEG_VIDEO_MUTE 		(V4L2_CID_MPEG_BASE+210)
+#define V4L2_CID_MPEG_VIDEO_MUTE_YUV 		(V4L2_CID_MPEG_BASE+211)
+
+/*  MPEG-class control IDs specific to the CX2341x driver as defined by V4L2 */
+#define V4L2_CID_MPEG_CX2341X_BASE 				(V4L2_CTRL_CLASS_MPEG | 0x1000)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE 	(V4L2_CID_MPEG_CX2341X_BASE+0)
+enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
+	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
+	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO   = 1,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER 		(V4L2_CID_MPEG_CX2341X_BASE+1)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE 	(V4L2_CID_MPEG_CX2341X_BASE+2)
+enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF                  = 0,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR               = 1,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT              = 2,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE      = 3,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE 	(V4L2_CID_MPEG_CX2341X_BASE+3)
+enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
+	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF    = 0,
+	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE 	(V4L2_CID_MPEG_CX2341X_BASE+4)
+enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
+	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
+	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO   = 1,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER 		(V4L2_CID_MPEG_CX2341X_BASE+5)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE 		(V4L2_CID_MPEG_CX2341X_BASE+6)
+enum v4l2_mpeg_cx2341x_video_median_filter_type {
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF      = 0,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR      = 1,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT     = 2,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG     = 4,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM 	(V4L2_CID_MPEG_CX2341X_BASE+7)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP 	(V4L2_CID_MPEG_CX2341X_BASE+8)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM	(V4L2_CID_MPEG_CX2341X_BASE+9)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP 	(V4L2_CID_MPEG_CX2341X_BASE+10)
+#define V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS 	(V4L2_CID_MPEG_CX2341X_BASE+11)
+
+/*  Camera class control IDs */
+#define V4L2_CID_CAMERA_CLASS_BASE 	(V4L2_CTRL_CLASS_CAMERA | 0x900)
+#define V4L2_CID_CAMERA_CLASS 		(V4L2_CTRL_CLASS_CAMERA | 1)
+
+#define V4L2_CID_EXPOSURE_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+1)
+enum  v4l2_exposure_auto_type {
+	V4L2_EXPOSURE_AUTO = 0,
+	V4L2_EXPOSURE_MANUAL = 1,
+	V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
+	V4L2_EXPOSURE_APERTURE_PRIORITY = 3
+};
+#define V4L2_CID_EXPOSURE_ABSOLUTE		(V4L2_CID_CAMERA_CLASS_BASE+2)
+#define V4L2_CID_EXPOSURE_AUTO_PRIORITY		(V4L2_CID_CAMERA_CLASS_BASE+3)
+
+#define V4L2_CID_PAN_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+4)
+#define V4L2_CID_TILT_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+5)
+#define V4L2_CID_PAN_RESET			(V4L2_CID_CAMERA_CLASS_BASE+6)
+#define V4L2_CID_TILT_RESET			(V4L2_CID_CAMERA_CLASS_BASE+7)
+
+#define V4L2_CID_PAN_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+8)
+#define V4L2_CID_TILT_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+9)
+
+#define V4L2_CID_FOCUS_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+10)
+#define V4L2_CID_FOCUS_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+11)
+#define V4L2_CID_FOCUS_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+12)
+
+#define V4L2_CID_ZOOM_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+13)
+#define V4L2_CID_ZOOM_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+14)
+#define V4L2_CID_ZOOM_CONTINUOUS		(V4L2_CID_CAMERA_CLASS_BASE+15)
+
+#define V4L2_CID_PRIVACY			(V4L2_CID_CAMERA_CLASS_BASE+16)
+
+/* FM Modulator class control IDs */
+#define V4L2_CID_FM_TX_CLASS_BASE		(V4L2_CTRL_CLASS_FM_TX | 0x900)
+#define V4L2_CID_FM_TX_CLASS			(V4L2_CTRL_CLASS_FM_TX | 1)
+
+#define V4L2_CID_RDS_TX_DEVIATION		(V4L2_CID_FM_TX_CLASS_BASE + 1)
+#define V4L2_CID_RDS_TX_PI			(V4L2_CID_FM_TX_CLASS_BASE + 2)
+#define V4L2_CID_RDS_TX_PTY			(V4L2_CID_FM_TX_CLASS_BASE + 3)
+#define V4L2_CID_RDS_TX_PS_NAME			(V4L2_CID_FM_TX_CLASS_BASE + 5)
+#define V4L2_CID_RDS_TX_RADIO_TEXT		(V4L2_CID_FM_TX_CLASS_BASE + 6)
+
+#define V4L2_CID_AUDIO_LIMITER_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 64)
+#define V4L2_CID_AUDIO_LIMITER_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 65)
+#define V4L2_CID_AUDIO_LIMITER_DEVIATION	(V4L2_CID_FM_TX_CLASS_BASE + 66)
+
+#define V4L2_CID_AUDIO_COMPRESSION_ENABLED	(V4L2_CID_FM_TX_CLASS_BASE + 80)
+#define V4L2_CID_AUDIO_COMPRESSION_GAIN		(V4L2_CID_FM_TX_CLASS_BASE + 81)
+#define V4L2_CID_AUDIO_COMPRESSION_THRESHOLD	(V4L2_CID_FM_TX_CLASS_BASE + 82)
+#define V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 83)
+#define V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 84)
+
+#define V4L2_CID_PILOT_TONE_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 96)
+#define V4L2_CID_PILOT_TONE_DEVIATION		(V4L2_CID_FM_TX_CLASS_BASE + 97)
+#define V4L2_CID_PILOT_TONE_FREQUENCY		(V4L2_CID_FM_TX_CLASS_BASE + 98)
+
+#define V4L2_CID_TUNE_PREEMPHASIS		(V4L2_CID_FM_TX_CLASS_BASE + 112)
+enum v4l2_preemphasis {
+	V4L2_PREEMPHASIS_DISABLED	= 0,
+	V4L2_PREEMPHASIS_50_uS		= 1,
+	V4L2_PREEMPHASIS_75_uS		= 2,
+};
+#define V4L2_CID_TUNE_POWER_LEVEL		(V4L2_CID_FM_TX_CLASS_BASE + 113)
+#define V4L2_CID_TUNE_ANTENNA_CAPACITOR		(V4L2_CID_FM_TX_CLASS_BASE + 114)
+
+/*
+ *	T U N I N G
+ */
+struct v4l2_tuner {
+	__u32                   index;
+	__u8			name[32];
+	enum v4l2_tuner_type    type;
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			rxsubchans;
+	__u32			audmode;
+	__s32			signal;
+	__s32			afc;
+	__u32			reserved[4];
+};
+
+struct v4l2_modulator {
+	__u32			index;
+	__u8			name[32];
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			txsubchans;
+	__u32			reserved[4];
+};
+
+/*  Flags for the 'capability' field */
+#define V4L2_TUNER_CAP_LOW		0x0001
+#define V4L2_TUNER_CAP_NORM		0x0002
+#define V4L2_TUNER_CAP_STEREO		0x0010
+#define V4L2_TUNER_CAP_LANG2		0x0020
+#define V4L2_TUNER_CAP_SAP		0x0020
+#define V4L2_TUNER_CAP_LANG1		0x0040
+#define V4L2_TUNER_CAP_RDS		0x0080
+
+/*  Flags for the 'rxsubchans' field */
+#define V4L2_TUNER_SUB_MONO		0x0001
+#define V4L2_TUNER_SUB_STEREO		0x0002
+#define V4L2_TUNER_SUB_LANG2		0x0004
+#define V4L2_TUNER_SUB_SAP		0x0004
+#define V4L2_TUNER_SUB_LANG1		0x0008
+#define V4L2_TUNER_SUB_RDS		0x0010
+
+/*  Values for the 'audmode' field */
+#define V4L2_TUNER_MODE_MONO		0x0000
+#define V4L2_TUNER_MODE_STEREO		0x0001
+#define V4L2_TUNER_MODE_LANG2		0x0002
+#define V4L2_TUNER_MODE_SAP		0x0002
+#define V4L2_TUNER_MODE_LANG1		0x0003
+#define V4L2_TUNER_MODE_LANG1_LANG2	0x0004
+
+struct v4l2_frequency {
+	__u32		      tuner;
+	enum v4l2_tuner_type  type;
+	__u32		      frequency;
+	__u32		      reserved[8];
+};
+
+struct v4l2_hw_freq_seek {
+	__u32		      tuner;
+	enum v4l2_tuner_type  type;
+	__u32		      seek_upward;
+	__u32		      wrap_around;
+	__u32		      reserved[8];
+};
+
+/*
+ *	R D S
+ */
+
+struct v4l2_rds_data {
+	__u8 	lsb;
+	__u8 	msb;
+	__u8 	block;
+} __attribute__ ((packed));
+
+#define V4L2_RDS_BLOCK_MSK 	 0x7
+#define V4L2_RDS_BLOCK_A 	 0
+#define V4L2_RDS_BLOCK_B 	 1
+#define V4L2_RDS_BLOCK_C 	 2
+#define V4L2_RDS_BLOCK_D 	 3
+#define V4L2_RDS_BLOCK_C_ALT 	 4
+#define V4L2_RDS_BLOCK_INVALID 	 7
+
+#define V4L2_RDS_BLOCK_CORRECTED 0x40
+#define V4L2_RDS_BLOCK_ERROR 	 0x80
+
+/*
+ *	A U D I O
+ */
+struct v4l2_audio {
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+
+/*  Flags for the 'capability' field */
+#define V4L2_AUDCAP_STEREO		0x00001
+#define V4L2_AUDCAP_AVL			0x00002
+
+/*  Flags for the 'mode' field */
+#define V4L2_AUDMODE_AVL		0x00001
+
+struct v4l2_audioout {
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+
+/*
+ *	M P E G   S E R V I C E S
+ *
+ *	NOTE: EXPERIMENTAL API
+ */
+#if 1
+#define V4L2_ENC_IDX_FRAME_I    (0)
+#define V4L2_ENC_IDX_FRAME_P    (1)
+#define V4L2_ENC_IDX_FRAME_B    (2)
+#define V4L2_ENC_IDX_FRAME_MASK (0xf)
+
+struct v4l2_enc_idx_entry {
+	__u64 offset;
+	__u64 pts;
+	__u32 length;
+	__u32 flags;
+	__u32 reserved[2];
+};
+
+#define V4L2_ENC_IDX_ENTRIES (64)
+struct v4l2_enc_idx {
+	__u32 entries;
+	__u32 entries_cap;
+	__u32 reserved[4];
+	struct v4l2_enc_idx_entry entry[V4L2_ENC_IDX_ENTRIES];
+};
+
+
+#define V4L2_ENC_CMD_START      (0)
+#define V4L2_ENC_CMD_STOP       (1)
+#define V4L2_ENC_CMD_PAUSE      (2)
+#define V4L2_ENC_CMD_RESUME     (3)
+
+/* Flags for V4L2_ENC_CMD_STOP */
+#define V4L2_ENC_CMD_STOP_AT_GOP_END    (1 << 0)
+
+struct v4l2_encoder_cmd {
+	__u32 cmd;
+	__u32 flags;
+	union {
+		struct {
+			__u32 data[8];
+		} raw;
+	};
+};
+
+#endif
+
+
+/*
+ *	D A T A   S E R V I C E S   ( V B I )
+ *
+ *	Data services API by Michael Schimek
+ */
+
+/* Raw VBI */
+struct v4l2_vbi_format {
+	__u32	sampling_rate;		/* in 1 Hz */
+	__u32	offset;
+	__u32	samples_per_line;
+	__u32	sample_format;		/* V4L2_PIX_FMT_* */
+	__s32	start[2];
+	__u32	count[2];
+	__u32	flags;			/* V4L2_VBI_* */
+	__u32	reserved[2];		/* must be zero */
+};
+
+/*  VBI flags  */
+#define V4L2_VBI_UNSYNC		(1 << 0)
+#define V4L2_VBI_INTERLACED	(1 << 1)
+
+/* Sliced VBI
+ *
+ *    This implements is a proposal V4L2 API to allow SLICED VBI
+ * required for some hardware encoders. It should change without
+ * notice in the definitive implementation.
+ */
+
+struct v4l2_sliced_vbi_format {
+	__u16   service_set;
+	/* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
+	   service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
+				 (equals frame lines 313-336 for 625 line video
+				  standards, 263-286 for 525 line standards) */
+	__u16   service_lines[2][24];
+	__u32   io_size;
+	__u32   reserved[2];            /* must be zero */
+};
+
+/* Teletext World System Teletext
+   (WST), defined on ITU-R BT.653-2 */
+#define V4L2_SLICED_TELETEXT_B          (0x0001)
+/* Video Program System, defined on ETS 300 231*/
+#define V4L2_SLICED_VPS                 (0x0400)
+/* Closed Caption, defined on EIA-608 */
+#define V4L2_SLICED_CAPTION_525         (0x1000)
+/* Wide Screen System, defined on ITU-R BT1119.1 */
+#define V4L2_SLICED_WSS_625             (0x4000)
+
+#define V4L2_SLICED_VBI_525             (V4L2_SLICED_CAPTION_525)
+#define V4L2_SLICED_VBI_625             (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)
+
+struct v4l2_sliced_vbi_cap {
+	__u16   service_set;
+	/* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
+	   service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
+				 (equals frame lines 313-336 for 625 line video
+				  standards, 263-286 for 525 line standards) */
+	__u16   service_lines[2][24];
+	enum v4l2_buf_type type;
+	__u32   reserved[3];    /* must be 0 */
+};
+
+struct v4l2_sliced_vbi_data {
+	__u32   id;
+	__u32   field;          /* 0: first field, 1: second field */
+	__u32   line;           /* 1-23 */
+	__u32   reserved;       /* must be 0 */
+	__u8    data[48];
+};
+
+/*
+ * Sliced VBI data inserted into MPEG Streams
+ */
+
+/*
+ * V4L2_MPEG_STREAM_VBI_FMT_IVTV:
+ *
+ * Structure of payload contained in an MPEG 2 Private Stream 1 PES Packet in an
+ * MPEG-2 Program Pack that contains V4L2_MPEG_STREAM_VBI_FMT_IVTV Sliced VBI
+ * data
+ *
+ * Note, the MPEG-2 Program Pack and Private Stream 1 PES packet header
+ * definitions are not included here.  See the MPEG-2 specifications for details
+ * on these headers.
+ */
+
+/* Line type IDs */
+#define V4L2_MPEG_VBI_IVTV_TELETEXT_B     (1)
+#define V4L2_MPEG_VBI_IVTV_CAPTION_525    (4)
+#define V4L2_MPEG_VBI_IVTV_WSS_625        (5)
+#define V4L2_MPEG_VBI_IVTV_VPS            (7)
+
+struct v4l2_mpeg_vbi_itv0_line {
+	__u8 id;	/* One of V4L2_MPEG_VBI_IVTV_* above */
+	__u8 data[42];	/* Sliced VBI data for the line */
+} __attribute__ ((packed));
+
+struct v4l2_mpeg_vbi_itv0 {
+	__le32 linemask[2]; /* Bitmasks of VBI service lines present */
+	struct v4l2_mpeg_vbi_itv0_line line[35];
+} __attribute__ ((packed));
+
+struct v4l2_mpeg_vbi_ITV0 {
+	struct v4l2_mpeg_vbi_itv0_line line[36];
+} __attribute__ ((packed));
+
+#define V4L2_MPEG_VBI_IVTV_MAGIC0	"itv0"
+#define V4L2_MPEG_VBI_IVTV_MAGIC1	"ITV0"
+
+struct v4l2_mpeg_vbi_fmt_ivtv {
+	__u8 magic[4];
+	union {
+		struct v4l2_mpeg_vbi_itv0 itv0;
+		struct v4l2_mpeg_vbi_ITV0 ITV0;
+	};
+} __attribute__ ((packed));
+
+/*
+ *	A G G R E G A T E   S T R U C T U R E S
+ */
+
+/*	Stream data format
+ */
+struct v4l2_format {
+	enum v4l2_buf_type type;
+	union {
+		struct v4l2_pix_format		pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */
+		struct v4l2_window		win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
+		struct v4l2_vbi_format		vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
+		struct v4l2_sliced_vbi_format	sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
+		__u8	raw_data[200];                   /* user-defined */
+	} fmt;
+};
+
+
+/*	Stream type-dependent parameters
+ */
+struct v4l2_streamparm {
+	enum v4l2_buf_type type;
+	union {
+		struct v4l2_captureparm	capture;
+		struct v4l2_outputparm	output;
+		__u8	raw_data[200];  /* user-defined */
+	} parm;
+};
+
+/*
+ *	A D V A N C E D   D E B U G G I N G
+ *
+ *	NOTE: EXPERIMENTAL API, NEVER RELY ON THIS IN APPLICATIONS!
+ *	FOR DEBUGGING, TESTING AND INTERNAL USE ONLY!
+ */
+
+/* VIDIOC_DBG_G_REGISTER and VIDIOC_DBG_S_REGISTER */
+
+#define V4L2_CHIP_MATCH_HOST       0  /* Match against chip ID on host (0 for the host) */
+#define V4L2_CHIP_MATCH_I2C_DRIVER 1  /* Match against I2C driver name */
+#define V4L2_CHIP_MATCH_I2C_ADDR   2  /* Match against I2C 7-bit address */
+#define V4L2_CHIP_MATCH_AC97       3  /* Match against anciliary AC97 chip */
+
+struct v4l2_dbg_match {
+	__u32 type; /* Match type */
+	union {     /* Match this chip, meaning determined by type */
+		__u32 addr;
+		char name[32];
+	};
+} __attribute__ ((packed));
+
+struct v4l2_dbg_register {
+	struct v4l2_dbg_match match;
+	__u32 size;	/* register size in bytes */
+	__u64 reg;
+	__u64 val;
+} __attribute__ ((packed));
+
+/* VIDIOC_DBG_G_CHIP_IDENT */
+struct v4l2_dbg_chip_ident {
+	struct v4l2_dbg_match match;
+	__u32 ident;       /* chip identifier as specified in <media/v4l2-chip-ident.h> */
+	__u32 revision;    /* chip revision, chip specific */
+} __attribute__ ((packed));
+
+/*
+ *	I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
+ *
+ */
+#define VIDIOC_QUERYCAP		 _IOR('V',  0, struct v4l2_capability)
+#define VIDIOC_RESERVED		  _IO('V',  1)
+#define VIDIOC_ENUM_FMT         _IOWR('V',  2, struct v4l2_fmtdesc)
+#define VIDIOC_G_FMT		_IOWR('V',  4, struct v4l2_format)
+#define VIDIOC_S_FMT		_IOWR('V',  5, struct v4l2_format)
+#define VIDIOC_REQBUFS		_IOWR('V',  8, struct v4l2_requestbuffers)
+#define VIDIOC_QUERYBUF		_IOWR('V',  9, struct v4l2_buffer)
+#define VIDIOC_G_FBUF		 _IOR('V', 10, struct v4l2_framebuffer)
+#define VIDIOC_S_FBUF		 _IOW('V', 11, struct v4l2_framebuffer)
+#define VIDIOC_OVERLAY		 _IOW('V', 14, int)
+#define VIDIOC_QBUF		_IOWR('V', 15, struct v4l2_buffer)
+#define VIDIOC_DQBUF		_IOWR('V', 17, struct v4l2_buffer)
+#define VIDIOC_STREAMON		 _IOW('V', 18, int)
+#define VIDIOC_STREAMOFF	 _IOW('V', 19, int)
+#define VIDIOC_G_PARM		_IOWR('V', 21, struct v4l2_streamparm)
+#define VIDIOC_S_PARM		_IOWR('V', 22, struct v4l2_streamparm)
+#define VIDIOC_G_STD		 _IOR('V', 23, v4l2_std_id)
+#define VIDIOC_S_STD		 _IOW('V', 24, v4l2_std_id)
+#define VIDIOC_ENUMSTD		_IOWR('V', 25, struct v4l2_standard)
+#define VIDIOC_ENUMINPUT	_IOWR('V', 26, struct v4l2_input)
+#define VIDIOC_G_CTRL		_IOWR('V', 27, struct v4l2_control)
+#define VIDIOC_S_CTRL		_IOWR('V', 28, struct v4l2_control)
+#define VIDIOC_G_TUNER		_IOWR('V', 29, struct v4l2_tuner)
+#define VIDIOC_S_TUNER		 _IOW('V', 30, struct v4l2_tuner)
+#define VIDIOC_G_AUDIO		 _IOR('V', 33, struct v4l2_audio)
+#define VIDIOC_S_AUDIO		 _IOW('V', 34, struct v4l2_audio)
+#define VIDIOC_QUERYCTRL	_IOWR('V', 36, struct v4l2_queryctrl)
+#define VIDIOC_QUERYMENU	_IOWR('V', 37, struct v4l2_querymenu)
+#define VIDIOC_G_INPUT		 _IOR('V', 38, int)
+#define VIDIOC_S_INPUT		_IOWR('V', 39, int)
+#define VIDIOC_G_OUTPUT		 _IOR('V', 46, int)
+#define VIDIOC_S_OUTPUT		_IOWR('V', 47, int)
+#define VIDIOC_ENUMOUTPUT	_IOWR('V', 48, struct v4l2_output)
+#define VIDIOC_G_AUDOUT		 _IOR('V', 49, struct v4l2_audioout)
+#define VIDIOC_S_AUDOUT		 _IOW('V', 50, struct v4l2_audioout)
+#define VIDIOC_G_MODULATOR	_IOWR('V', 54, struct v4l2_modulator)
+#define VIDIOC_S_MODULATOR	 _IOW('V', 55, struct v4l2_modulator)
+#define VIDIOC_G_FREQUENCY	_IOWR('V', 56, struct v4l2_frequency)
+#define VIDIOC_S_FREQUENCY	 _IOW('V', 57, struct v4l2_frequency)
+#define VIDIOC_CROPCAP		_IOWR('V', 58, struct v4l2_cropcap)
+#define VIDIOC_G_CROP		_IOWR('V', 59, struct v4l2_crop)
+#define VIDIOC_S_CROP		 _IOW('V', 60, struct v4l2_crop)
+#define VIDIOC_G_JPEGCOMP	 _IOR('V', 61, struct v4l2_jpegcompression)
+#define VIDIOC_S_JPEGCOMP	 _IOW('V', 62, struct v4l2_jpegcompression)
+#define VIDIOC_QUERYSTD      	 _IOR('V', 63, v4l2_std_id)
+#define VIDIOC_TRY_FMT      	_IOWR('V', 64, struct v4l2_format)
+#define VIDIOC_ENUMAUDIO	_IOWR('V', 65, struct v4l2_audio)
+#define VIDIOC_ENUMAUDOUT	_IOWR('V', 66, struct v4l2_audioout)
+#define VIDIOC_G_PRIORITY        _IOR('V', 67, enum v4l2_priority)
+#define VIDIOC_S_PRIORITY        _IOW('V', 68, enum v4l2_priority)
+#define VIDIOC_G_SLICED_VBI_CAP _IOWR('V', 69, struct v4l2_sliced_vbi_cap)
+#define VIDIOC_LOG_STATUS         _IO('V', 70)
+#define VIDIOC_G_EXT_CTRLS	_IOWR('V', 71, struct v4l2_ext_controls)
+#define VIDIOC_S_EXT_CTRLS	_IOWR('V', 72, struct v4l2_ext_controls)
+#define VIDIOC_TRY_EXT_CTRLS	_IOWR('V', 73, struct v4l2_ext_controls)
+#if 1
+#define VIDIOC_ENUM_FRAMESIZES	_IOWR('V', 74, struct v4l2_frmsizeenum)
+#define VIDIOC_ENUM_FRAMEINTERVALS _IOWR('V', 75, struct v4l2_frmivalenum)
+#define VIDIOC_G_ENC_INDEX       _IOR('V', 76, struct v4l2_enc_idx)
+#define VIDIOC_ENCODER_CMD      _IOWR('V', 77, struct v4l2_encoder_cmd)
+#define VIDIOC_TRY_ENCODER_CMD  _IOWR('V', 78, struct v4l2_encoder_cmd)
+#endif
+
+#if 1
+/* Experimental, meant for debugging, testing and internal use.
+   Only implemented if CONFIG_VIDEO_ADV_DEBUG is defined.
+   You must be root to use these ioctls. Never use these in applications! */
+#define	VIDIOC_DBG_S_REGISTER 	 _IOW('V', 79, struct v4l2_dbg_register)
+#define	VIDIOC_DBG_G_REGISTER 	_IOWR('V', 80, struct v4l2_dbg_register)
+
+/* Experimental, meant for debugging, testing and internal use.
+   Never use this ioctl in applications! */
+#define VIDIOC_DBG_G_CHIP_IDENT _IOWR('V', 81, struct v4l2_dbg_chip_ident)
+#endif
+
+#define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
+/* Reminder: when adding new ioctls please add support for them to
+   drivers/media/video/v4l2-compat-ioctl32.c as well! */
+
+#ifdef __OLD_VIDIOC_
+/* for compatibility, will go away some day */
+#define VIDIOC_OVERLAY_OLD     	_IOWR('V', 14, int)
+#define VIDIOC_S_PARM_OLD      	 _IOW('V', 22, struct v4l2_streamparm)
+#define VIDIOC_S_CTRL_OLD      	 _IOW('V', 28, struct v4l2_control)
+#define VIDIOC_G_AUDIO_OLD     	_IOWR('V', 33, struct v4l2_audio)
+#define VIDIOC_G_AUDOUT_OLD    	_IOWR('V', 49, struct v4l2_audioout)
+#define VIDIOC_CROPCAP_OLD     	 _IOR('V', 58, struct v4l2_cropcap)
+#endif
+
+#define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
+
+#endif /* __LINUX_VIDEODEV2_H */
